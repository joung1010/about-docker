## Docker란?

### 🐳 Docker의 정의

**Docker란?**

**컨테이너**를 사용하여 각각의 프로그램을 **분리된 환경**에서 실행 및 관리할 수 있는 툴이에요.

### 📦 컨테이너(Container)란?

윈도우 환경을 사용해보면 하나의 컴퓨터에 여러 사용자로 나눠서 사용할 수 있게끔 구성되어 있어요. 각 사용자의 환경에 들어가보면 독립적으로 구성되어 있어서 필요한 프로그램을 각 사용자 환경에 따로따로 설치해주어야 하죠.

컨테이너도 이와 비슷한 개념이에요. 하나의 컴퓨터 환경 내에서 **독립적인 컴퓨터 환경**을 구성해서, 각 환경에 프로그램을 별도로 설치할 수 있게 만든 개념이에요. 하나의 컴퓨터 환경 내에서 여러개의 **미니 컴퓨터 환경**을 구성할 수 있는 형태죠.

```
Host Computer (실제 컴퓨터)
┌─────────────────────────────────────────────────┐
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐│
│  │Container 1  │  │Container 2  │  │Container 3  ││
│  │(미니컴퓨터1) │  │(미니컴퓨터2) │  │(미니컴퓨터3) ││
│  │             │  │             │  │             ││
│  │ Node.js App │  │ MySQL DB    │  │ Redis Cache ││
│  │             │  │             │  │             ││
│  └─────────────┘  └─────────────┘  └─────────────┘│
└─────────────────────────────────────────────────┘
```

여기서 얘기하는 **미니 컴퓨터**를 보고 Docker에서는 **컨테이너(Container)**라고 불러요.

**(컨테이너(Container)를 이해할 때 머릿속의 이미지로 미니 컴퓨터를 떠올리면 이해하기 편해요.)**

여기서 '**컨테이너**'와 '**컨테이너를 포함하고 있는 컴퓨터**'를 구분하기 위해 컨테이너를 포함하고 있는 컴퓨터를 '**호스트(host) 컴퓨터**'라고 부르죠.

### 🔧 Docker Engine과 컨테이너 런타임

Docker를 처음 할 때 헷갈리는 부분 중 하나가 **Docker Engine**의 역할이에요.

### **Docker Engine이란?**

```
Docker 아키텍처:
┌─────────────────────────────────────────────────┐
│                 Docker Client                   │
│         (docker run, docker build 명령어)       │
└─────────────────────────────────────────────────┘
                        ↕ REST API
┌─────────────────────────────────────────────────┐
│                Docker Engine                    │
│  ┌─────────────────────────────────────────────┐│
│  │           Docker Daemon                     ││
│  │  ┌─────────────────────────────────────────┐││
│  │  │ 1. 이미지 관리                          │││
│  │  │   - 이미지 다운로드/삭제/빌드           │││
│  │  │   - 레이어 캐싱 및 관리                 │││
│  │  │                                        │││
│  │  │ 2. 컨테이너 생명주기 관리               │││
│  │  │   - 컨테이너 생성/시작/중지/삭제        │││
│  │  │   - 리소스 할당 및 모니터링             │││
│  │  │                                        │││
│  │  │ 3. 네트워크 관리                        │││
│  │  │   - 가상 네트워크 생성/관리             │││
│  │  │   - 포트 포워딩 및 브릿지 설정          │││
│  │  │                                        │││
│  │  │ 4. 볼륨 관리                           │││
│  │  │   - 데이터 영속성 보장                  │││
│  │  │   - 호스트와 컨테이너 간 파일 공유      │││
│  │  └─────────────────────────────────────────┘││
│  └─────────────────────────────────────────────┘│
└─────────────────────────────────────────────────┘
                        ↕
┌─────────────────────────────────────────────────┐
│              Container Runtime                  │
│               (containerd + runc)               │
│  ┌─────────────────────────────────────────────┐│
│  │ - 실제 컨테이너 프로세스 실행               ││
│  │ - 네임스페이스와 cgroups 설정               ││
│  │ - 보안 격리 및 자원 제한 적용               ││
│  └─────────────────────────────────────────────┘│
└─────────────────────────────────────────────────┘
                        ↕
┌─────────────────────────────────────────────────┐
│                Host OS Kernel                   │
└─────────────────────────────────────────────────┘
```

### **Container Runtime의 역할**

**Container Runtime**은 실제로 컨테이너를 실행하는 저수준 컴포넌트예요.

```
Container Runtime이 하는 일:

1. 네임스페이스 생성:
   ┌─────────────────────────────────────────────┐
   │ PID 네임스페이스: 프로세스 ID 격리           │
   │ Network 네임스페이스: 네트워크 격리          │
   │ Mount 네임스페이스: 파일시스템 격리          │
   │ UTS 네임스페이스: 호스트명 격리             │
   │ IPC 네임스페이스: 프로세스 간 통신 격리      │
   │ User 네임스페이스: 사용자 권한 격리          │
   └─────────────────────────────────────────────┘

2. cgroups 설정:
   ┌─────────────────────────────────────────────┐
   │ memory.limit_in_bytes: 메모리 제한           │
   │ cpu.cfs_quota_us: CPU 사용량 제한           │
   │ blkio.throttle.read_bps_device: I/O 제한    │
   │ pids.max: 프로세스 개수 제한                │
   └─────────────────────────────────────────────┘

3. 보안 정책 적용:
   ┌─────────────────────────────────────────────┐
   │ AppArmor/SELinux 프로파일 적용              │
   │ Seccomp 시스템 콜 필터링                    │
   │ Capability 제한 (CAP_NET_ADMIN 등)         │
   └─────────────────────────────────────────────┘
```

### **Docker Engine vs Container Runtime**

```
역할 분담:

Docker Engine (상위 레벨):
- 사용자 명령어 처리 (docker run, docker build)
- 이미지 다운로드 및 관리
- 네트워크와 볼륨 생성
- API 서버 역할

Container Runtime (하위 레벨):
- 실제 컨테이너 프로세스 실행
- 운영체제 수준의 격리 기능 설정
- 리소스 제한 및 보안 정책 적용

예시:
$ docker run nginx
   ↓ Docker Engine이 처리
1. nginx 이미지 확인/다운로드
2. 네트워크 설정 준비
3. 볼륨 마운트 설정
   ↓ Container Runtime에 위임
4. 네임스페이스 생성
5. cgroups 설정
6. nginx 프로세스 실행
```

### 🔒 컨테이너(Container)의 독립성

위의 설명에서 컨테이너는 '독립적인 컴퓨터 환경'이라고 얘기했어요. 구체적으로 어떤 것들이 독립적으로 관리되는지 기억해두죠.

### **디스크 (저장 공간)**

각 컨테이너마다 서로 각자의 저장 공간을 가지고 있어요. 일반적으로 A 컨테이너 내부에서 B 컨테이너 내부에 있는 파일에 접근할 수 없어요.

```
파일시스템 격리:
Host OS
├─ /var/lib/docker/overlay2/[container1-id]/
│  ├─ /app/server.js (Container 1의 파일)
│  └─ /data/config.json
├─ /var/lib/docker/overlay2/[container2-id]/
│  ├─ /app/index.html (Container 2의 파일)  
│  └─ /logs/access.log
└─ /home/user/documents/ (Host OS 파일)

Container 1에서:
$ ls /app/
server.js  *# Container 1의 파일만 보임*
$ ls /  
bin  etc  lib  usr  app  *# Container 1만의 루트 파일시스템*

Container 2에서:
$ ls /app/
index.html  *# Container 2의 파일만 보임 (server.js 접근 불가)*
```

### **네트워크 (IP, Port)**

각 컨테이너마다 고유의 네트워크를 가지고 있어요. 컨테이너는 각자의 IP 주소를 가지고 있어요.

bash

`네트워크 격리:
Host OS (192.168.1.100)
├─ docker0 브릿지 (172.17.0.1)
├─ Container 1 (172.17.0.2:80)
│  └─ nginx 웹서버
├─ Container 2 (172.17.0.3:3306)  
│  └─ MySQL 데이터베이스
└─ Container 3 (172.17.0.4:6379)
└─ Redis 캐시서버

포트 독립성:
- Container 1, 2, 3 모두 내부적으로 80 포트 사용 가능
- 외부에서는 서로 다른 포트로 접근
    - Container 1: localhost:8080 → 172.17.0.2:80
    - Container 2: localhost:8081 → 172.17.0.3:80
    - Container 3: localhost:8082 → 172.17.0.4:80`

### **프로세스 격리**

bash

`프로세스 네임스페이스 격리:
Host OS에서:
$ ps aux
PID  COMMAND
1    /sbin/init
100  dockerd
150  containerd  
200  nginx (Container 1)
250  mysqld (Container 2)
300  redis-server (Container 3)

Container 1에서:
$ ps aux
PID  COMMAND
1    nginx: master process  *# Container 내부에서는 PID 1*
2    nginx: worker process

Container 2에서:
$ ps aux  
PID  COMMAND
1    mysqld  *# 각 Container마다 독립적인 PID 1*`

### 💿 이미지(Image)란?

닌텐도와 같은 게임기를 보면 여러가지 칩을 꽂아서 다양한 게임을 즐길 수 있게 되어 있어요. Docker에서는 **닌텐도의 칩**과 같은 역할을 하는 개념이 **이미지(Image)**예요.

```
게임기 비유:
┌─────────────────────────────────────────────────┐
│              닌텐도 게임기 (Docker Engine)        │
│  ┌─────────────────────────────────────────────┐│
│  │ 마리오 칩 삽입 → 마리오 게임 실행           ││
│  │ 젤다 칩 삽입 → 젤다 게임 실행               ││
│  │ 포켓몬 칩 삽입 → 포켓몬 게임 실행           ││
│  └─────────────────────────────────────────────┘│
└─────────────────────────────────────────────────┘

Docker 방식:
┌─────────────────────────────────────────────────┐
│                Docker Engine                    │
│  ┌─────────────────────────────────────────────┐│
│  │ Node.js 이미지 실행 → Node.js 컨테이너      ││
│  │ MySQL 이미지 실행 → MySQL 컨테이너          ││
│  │ Redis 이미지 실행 → Redis 컨테이너          ││
│  └─────────────────────────────────────────────┘│
└─────────────────────────────────────────────────┘
```

### **구체적인 예시들**

**Node.js 기반의 Express.js 서버 프로젝트**를 이미지로 만들었다고 가정해보죠. 이 이미지를 Docker로 실행시키면 Express.js 서버 프로젝트가 컨테이너(Container) 환경에서 실행돼요. 복잡한 설치 과정을 거칠 필요 없이 손쉽게 실행되죠.

```
Express.js 이미지 실행:
$ docker run -p 3000:3000 my-express-app

내부적으로 일어나는 일:
1. my-express-app 이미지에서 컨테이너 생성
2. Node.js 런타임 환경 설정
3. npm 의존성 패키지들 로드
4. Express.js 서버 시작 (포트 3000)
5. 호스트의 3000 포트와 연결
→ localhost:3000으로 바로 접근 가능
```

또 다른 예로, **MySQL 서버**를 이미지로 만들었다면, 이 이미지를 Docker로 실행시키는 순간 MySQL 서버가 컨테이너(Container) 환경에서 실행돼요. MySQL을 일일이 설치할 필요없이 MySQL 데이터베이스를 사용할 수 있게 되죠.

```
MySQL 이미지 실행:
$ docker run -d -p 3306:3306 -e MYSQL_ROOT_PASSWORD=mypassword mysql:8.0

내부적으로 일어나는 일:
1. mysql:8.0 이미지에서 컨테이너 생성
2. MySQL 8.0 서버 바이너리 로드
3. 데이터베이스 초기화
4. Root 비밀번호 설정
5. MySQL 서비스 시작 (포트 3306)
→ 바로 데이터베이스 연결 가능
```

### **이미지(Image)의 구성 요소**

- *이미지(Image)**는 **프로그램을 실행하는 데 필요한 설치 과정, 설정, 버전 정보 등을 포함**하고 있어요. 즉, **프로그램을 실행하는 데 필요한 모든 것을 포함**하고 있죠.

```
Docker 이미지 구조 (레이어드 아키텍처):
┌─────────────────────────────────────────────────┐
│ Application Layer (읽기/쓰기 가능)               │
│ ┌─────────────────────────────────────────────┐ │
│ │ 컨테이너 실행 시 생성되는 레이어             │ │
│ │ - 로그 파일, 임시 파일, 캐시 등             │ │
│ └─────────────────────────────────────────────┘ │
├─────────────────────────────────────────────────┤
│ Custom Application Layer (읽기 전용)             │
│ ┌─────────────────────────────────────────────┐ │
│ │ 내가 만든 애플리케이션 코드                  │ │
│ │ - app.js, package.json, config files       │ │
│ └─────────────────────────────────────────────┘ │
├─────────────────────────────────────────────────┤
│ Runtime Layer (읽기 전용)                       │
│ ┌─────────────────────────────────────────────┐ │
│ │ 런타임 환경                                 │ │
│ │ - Node.js, Python, Java JRE 등             │ │
│ └─────────────────────────────────────────────┘ │
├─────────────────────────────────────────────────┤
│ OS Libraries Layer (읽기 전용)                  │
│ ┌─────────────────────────────────────────────┐ │
│ │ 운영체제 라이브러리                         │ │
│ │ - libc, libssl, 시스템 도구들               │ │
│ └─────────────────────────────────────────────┘ │
├─────────────────────────────────────────────────┤
│ Base OS Layer (읽기 전용)                       │
│ ┌─────────────────────────────────────────────┐ │
│ │ 기본 운영체제 (Alpine, Ubuntu, CentOS 등)   │ │
│ │ - /bin, /lib, /usr 디렉토리                 │ │
│ └─────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────┘
```

### **이미지와 컨테이너의 관계**

```
이미지 vs 컨테이너:

이미지 (Image):
- 실행 파일과 같은 개념 (예: game.exe)
- 읽기 전용 템플릿
- 여러 컨테이너가 공유 가능
- 변경되지 않음

컨테이너 (Container):  
- 실행 중인 프로세스와 같은 개념 (예: 실행 중인 게임)
- 이미지를 기반으로 생성된 실행 인스턴스
- 읽기/쓰기 가능한 레이어 추가
- 상태를 가짐 (시작, 중지, 일시정지 등)

관계:
MySQL 이미지 (1개) → MySQL 컨테이너 1 (개발용)
                   → MySQL 컨테이너 2 (테스트용)  
                   → MySQL 컨테이너 3 (운영용)

마치 Windows 설치 파일 하나로 여러 컴퓨터에 Windows를 설치하는 것과 같은 개념
```

### **이미지 빌드 과정**

```
Dockerfile 예시:
FROM node:16-alpine        *# 베이스 이미지*
WORKDIR /app              *# 작업 디렉토리 설정*
COPY package*.json ./     *# 의존성 파일 복사*
RUN npm install           *# 의존성 설치*
COPY . .                  *# 애플리케이션 코드 복사*
EXPOSE 3000              *# 포트 노출*
CMD ["npm", "start"]     *# 실행 명령어*

빌드 과정:
$ docker build -t my-app .

1. node:16-alpine 베이스 이미지 다운로드
2. /app 디렉토리 생성
3. package.json 복사 → 새 레이어 생성
4. npm install 실행 → 새 레이어 생성
5. 애플리케이션 코드 복사 → 새 레이어 생성
6. 메타데이터 설정 (포트, 실행 명령어)
7. my-app:latest 이미지 생성 완료
```

이렇게 Docker Engine과 Container Runtime의 역할, 그리고 이미지와 컨테이너의 관계를 이해하면 Docker의 전체적인 동작 원리를 파악할 수 있어요.