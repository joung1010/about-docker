## 컨테이너 생성/실행

### 📦 컨테이너 생성

이미지를 바탕으로 컨테이너를 **생성**해요. 이때, 컨테이너를 **실행시키지는 않아요**.

*(컨테이너를 실행하지 않고 생성만 하는 경우가 잘 없어서, 이 명령어는 잘 사용하지 않아요.)*

```bash
*# docker create 이미지명[:태그명]*
$ docker create nginx

$ docker ps -a *# 모든 컨테이너 조회*
```

### **docker create 상세 동작**

```
docker create 실행 과정:

1. 이미지 존재 확인:
   - 로컬에 nginx 이미지 있는지 확인
   - 없으면 Docker Hub에서 자동 다운로드 (docker pull nginx)

2. 컨테이너 생성:
   - 새로운 컨테이너 인스턴스 생성
   - 고유한 컨테이너 ID 할당 (64자리 해시)
   - 랜덤 이름 생성 (예: gracious_einstein)

3. 메타데이터 설정:
   - 이미지 정보 연결
   - 네트워크 설정 (기본값)
   - 볼륨 마운트 (기본값)
   - 환경 변수 (이미지 기본값)

4. 파일시스템 준비:
   - Copy-on-Write 레이어 생성
   - 이미지 레이어를 읽기 전용으로 마운트
   - 컨테이너 전용 쓰기 레이어 추가

출력 결과:
3f4d8e92a45b8c7d6e1f9a2e5c8b4f7d9e3a6c1b5f8e2d4c7a9f6e3b1d8c5a7e
(생성된 컨테이너 ID)
```

### **컨테이너 상태 확인**

```bash
$ docker ps -a
CONTAINER ID   IMAGE   COMMAND                  CREATED         STATUS    PORTS   NAMES
3f4d8e92a45b   nginx   "/docker-entrypoint.…"   2 minutes ago   Created           gracious_einstein

STATUS 설명:
- Created: 생성됨 (아직 실행되지 않음)
- Up: 실행 중
- Exited: 종료됨
- Paused: 일시정지됨
- Restarting: 재시작 중`
```

### 🚀 컨테이너 실행

정지되어 있는 컨테이너를 실행시켜요.

```bash
*# docker start 컨테이너명[또는 컨테이너 ID]*
$ docker start 컨테이너명[또는 컨테이너 ID]

$ docker ps *# 실행중인 컨테이너 조회*
```

### **docker start 상세 동작**

```
docker start 실행 과정:

1. 컨테이너 상태 확인:
   - 지정된 컨테이너 ID/이름으로 컨테이너 찾기
   - 현재 상태 확인 (Created, Exited 상태여야 시작 가능)

2. 리소스 할당:
   - CPU, 메모리 제한 적용
   - 네트워크 인터페이스 연결
   - 볼륨 마운트

3. 프로세스 실행:
   - 이미지에 정의된 ENTRYPOINT/CMD 실행
   - PID 1 프로세스로 시작
   - 네임스페이스 격리 적용

4. 상태 변경:
   - STATUS: Created → Up
   - 실행 시작 시간 기록

컨테이너명으로 실행:
$ docker start gracious_einstein

컨테이너 ID로 실행 (부분 ID 가능):
$ docker start 3f4d8e92a45b
$ docker start 3f4d        *# 앞 4자리로도 가능*
```

### **실행 중인 컨테이너 확인**

```bash
$ docker ps
CONTAINER ID   IMAGE   COMMAND                  CREATED         STATUS         PORTS   NAMES
3f4d8e92a45b   nginx   "/docker-entrypoint.…"   5 minutes ago   Up 2 minutes   80/tcp  gracious_einstein

주목할 점:
- STATUS가 "Up 2 minutes"로 변경됨
- PORTS에 80/tcp 표시 (nginx 기본 포트)
- 하지만 호스트에서 접근은 불가 (포트 매핑 안 됨)
```

### 🧹 컨테이너 정리

```bash
*# Nginx 컨테이너 중단 후 삭제하기*
$ docker ps *# 실행 중인 컨테이너 조회*
$ docker stop {nginx를 실행시킨 Container ID} *# 컨테이너 중단*
$ docker rm {nginx를 실행시킨 Container ID} *# 컨테이너 삭제*
$ docker image rm nginx *# Nginx 이미지 삭제*
```

### **정리 과정 상세**

```bash
단계별 정리:

1. 컨테이너 중지:
$ docker stop 3f4d8e92a45b
3f4d8e92a45b

내부 동작:
- SIGTERM 신호 전송 (정상 종료 요청)
- 10초 대기 (Grace Period)
- 응답 없으면 SIGKILL 전송 (강제 종료)

2. 컨테이너 삭제:
$ docker rm 3f4d8e92a45b
3f4d8e92a45b

내부 동작:
- 컨테이너 메타데이터 삭제
- 쓰기 레이어 삭제
- 네트워크 연결 해제
- 볼륨 언마운트 (볼륨 자체는 보존)

3. 이미지 삭제:
$ docker image rm nginx
Untagged: nginx:latest
Deleted: sha256:605c77e624dd...

주의사항:
- 다른 컨테이너가 같은 이미지 사용 중이면 삭제 불가
- 강제 삭제는 -f 옵션 사용
```

### 🏃‍♂️ 컨테이너 생성 + 실행

이미지를 바탕으로 컨테이너를 생성한 뒤, 컨테이너를 실행까지 시켜요.

*(처음에 이미지를 바탕으로 컨테이너를 실행시키고 싶을 때, 이 명령어를 자주 사용해요.)*

```bash
*# docker run 이미지명[:태그명]*
$ docker run nginx *# 포그라운드에서 실행 (추가적인 명령어 조작을 할 수가 없음)# Ctrl + C로 종료할 수 있음*
```

### **docker run = docker create + docker start**

```bash
docker run의 내부 동작:
$ docker run nginx
         ↓ 내부적으로 분해되면
$ docker create nginx  *# 컨테이너 생성*
$ docker start nginx   *# 컨테이너 시작*

하지만 실제로는 최적화되어 한 번에 처리됨

로컬 이미지 없을 때:
1. Docker Hub에서 이미지 다운로드 (docker pull nginx)
2. 컨테이너 생성
3. 컨테이너 시작

이미지 업데이트 확인:
- docker run은 로컬 이미지 사용
- 새로운 버전 확인하려면 먼저 docker pull 실행
```

### **포그라운드 실행의 특징**

bash

```bash
포그라운드 실행 시 출력:
$ docker run nginx
/docker-entrypoint.sh: /docker-entrypoint.d/ is not empty, will attempt to perform configuration
/docker-entrypoint.sh: Looking for shell scripts in /docker-entrypoint.d/
/docker-entrypoint.sh: Launching /docker-entrypoint.d/10-listen-on-ipv6-by-default.sh
...
2023/11/15 10:30:45 [notice] 1*#1: nginx/1.25.3*
2023/11/15 10:30:45 [notice] 1*#1: built by gcc 12.2.0 (Debian 12.2.0-14)*
2023/11/15 10:30:45 [notice] 1*#1: OS: Linux 5.15.49-linuxkit*
2023/11/15 10:30:45 [notice] 1*#1: getrlimit(RLIMIT_NOFILE): 1048576:1048576*
2023/11/15 10:30:45 [notice] 1*#1: start worker processes*

특징:
- 실시간 로그 출력
- 터미널이 블로킹됨 (다른 명령어 입력 불가)
- Ctrl+C로 컨테이너 종료
- 디버깅 시 유용
```

### 🌟 포그라운드 vs 백그라운드

> 포그라운드(foreground)**와 백그라운드(background)의 차이를 모르는 분들을 위해 간단히 정리하고 가죠.
>
>
> **포그라운드**는 **내가 실행시킨 프로그램의 내용이 화면에서 실행되고 출력되는 상태**를 뜻해요. 그러다보니 포그라운드 상태에서는 다른 프로그램을 조작할 수가 없어요.
>
> **백그라운드**는 **내가 실행시킨 프로그램이 컴퓨터 내부적으로 실행되는 상태**를 의미해요. 그래서 프로그램이 어떻게 실행되고 있는지에 대한 정보를 화면에서 확인할 수 없어요. 이런 특성 때문에 다른 명령어를 추가로 입력할 수도 있고, 새로운 프로그램을 조작할 수도 있어요.
>

### **실생활 비유**

```
포그라운드 (Foreground):
- TV 시청하면서 리모컨 조작
- 게임 플레이 중
- 화상회의 참여 중
→ 다른 일을 동시에 하기 어려움

백그라운드 (Background):
- 음악 스트리밍 (배경 재생)
- 파일 다운로드 (백그라운드 진행)
- 자동 백업 (백그라운드 실행)
→ 다른 일을 동시에 할 수 있음

Docker에서:
포그라운드: 로그 실시간 확인, 디버깅
백그라운드: 서비스 운영, 다중 컨테이너 관리
```

### 🔇 컨테이너를 백그라운드에서 실행시키기

```bash
*# docker run **-d** 이미지명[:태그명]*
$ docker run -d nginx
```

### **d 옵션 (detached mode)**

```bash
백그라운드 실행:
$ docker run -d nginx
3f4d8e92a45b8c7d6e1f9a2e5c8b4f7d9e3a6c1b5f8e2d4c7a9f6e3b1d8c5a7e

결과:
- 컨테이너 ID만 출력
- 프롬프트 즉시 복귀
- 다른 명령어 입력 가능
- 컨테이너는 백그라운드에서 계속 실행

실행 상태 확인:
$ docker ps
CONTAINER ID   IMAGE   COMMAND                  CREATED         STATUS         PORTS   NAMES
3f4d8e92a45b   nginx   "/docker-entrypoint.…"   1 minute ago    Up 1 minute    80/tcp  amazing_curie
```

### **백그라운드 실행의 장점**

```bash
다중 컨테이너 관리:
$ docker run -d --name web nginx
$ docker run -d --name db mysql:8.0
$ docker run -d --name cache redis

$ docker ps
CONTAINER ID   IMAGE     COMMAND     CREATED   STATUS      PORTS      NAMES
abc123def456   nginx     "..."       1 min     Up 1 min    80/tcp     web
def456abc123   mysql:8.0 "..."       1 min     Up 1 min    3306/tcp   db
789abc123def   redis     "..."       1 min     Up 1 min    6379/tcp   cache

모든 컨테이너가 동시에 백그라운드에서 실행됨
```

### 🧹 백그라운드 컨테이너 정리

```bash
*# Nginx 컨테이너 중단 후 삭제하기*
$ docker ps *# 실행 중인 컨테이너 조회*
$ docker stop {nginx를 실행시킨 Container ID} *# 컨테이너 중단*
$ docker rm {nginx를 실행시킨 Container ID} *# 컨테이너 삭제*
$ docker image rm nginx *# Nginx 이미지 삭제*
```

### 🏷️ 컨테이너에 이름 붙여서 생성 및 실행하기

bash

```bash
*# docker run -d **--name [컨테이너 이름]** 이미지명[:태그명]*
$ docker run -d --name my-web-server nginx
```

### **-name 옵션의 장점**

```bash
랜덤 이름 vs 지정 이름:

랜덤 이름 (기본):
$ docker run -d nginx
→ 이름: amazing_curie, gracious_einstein 등

지정 이름:
$ docker run -d --name my-web-server nginx
→ 이름: my-web-server

관리상 장점:
$ docker stop my-web-server     *# 기억하기 쉬움*
$ docker start my-web-server
$ docker logs my-web-server
$ docker exec -it my-web-server bash

vs

$ docker stop amazing_curie     *# 매번 이름 확인 필요*
$ docker start amazing_curie
```

### **컨테이너 이름 규칙**

```bash
이름 규칙:
✅ 허용: 영문자, 숫자, 하이픈(-), 언더스코어(_), 점(.)
✅ 예시: web-server, my_app, api.v1, nginx-prod

❌ 금지: 대문자, 공백, 특수문자(!@*#$% 등)*
❌ 예시: Web-Server, my app, api@v1

이름 중복 확인:
$ docker run -d --name web nginx      *# 성공*
$ docker run -d --name web mysql      *# 실패! 이름 중복*

Error: Conflict. The container name "/web" is already in use
```

### 🧹 이름 지정 컨테이너 정리

```bash
*# Nginx 컨테이너 중단 후 삭제하기*
$ docker ps *# 실행 중인 컨테이너 조회*
$ docker stop my-web-server *# 컨테이너 중단*
$ docker rm my-web-server *# 컨테이너 삭제*
$ docker image rm nginx *# Nginx 이미지 삭제*
```

### 🌐 호스트의 포트와 컨테이너의 포트를 연결하기

```bash
*# docker run -d **-p [호스트 포트]:[컨테이너 포트]** 이미지명[:태그명]*
$ docker run -d -p 4000:80 nginx
```

`docker run -p 4000:80`라고 명령어를 입력하게 되면, 도커를 실행하는 호스트의 4000번 포트를 컨테이너의 80번 포트로 연결하도록 설정해요.

### **포트 매핑 상세 원리**

```
포트 매핑 구조:
┌─────────────────────────────────────────────────┐
│                Host OS                          │
│  ┌─────────────────────────────────────────────┐│
│  │ 브라우저: localhost:4000 요청               ││
│  └─────────────────────────────────────────────┘│
│                     ↓                          │
│  ┌─────────────────────────────────────────────┐│
│  │ Docker Engine: 포트 포워딩                  ││
│  │ 4000 → 80 매핑 규칙 적용                   ││
│  └─────────────────────────────────────────────┘│
│                     ↓                          │
│  ┌─────────────────────────────────────────────┐│
│  │ Container (172.17.0.2:80)                  ││
│  │ ┌─────────────────────────────────────────┐ ││
│  │ │ Nginx 웹서버 (포트 80에서 대기)         │ ││
│  │ └─────────────────────────────────────────┘ ││
│  └─────────────────────────────────────────────┘│
└─────────────────────────────────────────────────┘

패킷 흐름:
외부 요청 → Host:4000 → Docker Bridge → Container:80 → Nginx
```

### **다양한 포트 매핑 방법**

```bash
기본 포트 매핑:
$ docker run -d -p 4000:80 nginx
*# 호스트 4000 → 컨테이너 80*

동일 포트 매핑:
$ docker run -d -p 80:80 nginx
*# 호스트 80 → 컨테이너 80*

여러 포트 매핑:
$ docker run -d -p 80:80 -p 443:443 nginx
*# HTTP와 HTTPS 동시 매핑*

IP 지정 매핑:
$ docker run -d -p 127.0.0.1:4000:80 nginx
*# 로컬호스트에서만 접근 가능*

랜덤 포트 매핑:
$ docker run -d -p 80 nginx
*# 호스트의 랜덤 포트 → 컨테이너 80*

포트 확인:
$ docker port [컨테이너명]
80/tcp -> 0.0.0.0:32768  *# 랜덤 포트 결과*
```

### **네트워크 구조 이해**

```bash
Docker 네트워크 스택:
┌─────────────────────────────────────────────────┐
│              Physical Network                   │
│                (인터넷)                          │
└─────────────────────────────────────────────────┘
                        ↕
┌─────────────────────────────────────────────────┐
│               Host Network                      │
│              (eth0: 192.168.1.100)             │
│  ┌─────────────────────────────────────────────┐│
│  │          iptables Rules                     ││
│  │  -A DOCKER -p tcp --dport 4000              ││
│  │   -j DNAT --to-destination 172.17.0.2:80   ││
│  └─────────────────────────────────────────────┘│
└─────────────────────────────────────────────────┘
                        ↕
┌─────────────────────────────────────────────────┐
│            Docker Bridge Network               │
│               (docker0: 172.17.0.1)            │
│  ┌─────────────────────────────────────────────┐│
│  │ Container 1 (172.17.0.2:80)  ← nginx       ││
│  │ Container 2 (172.17.0.3:3306) ← mysql      ││
│  │ Container 3 (172.17.0.4:6379) ← redis      ││
│  └─────────────────────────────────────────────┘│
└─────────────────────────────────────────────────┘
```

### **포트 매핑 동작 확인**

```bash
컨테이너 실행:
$ docker run -d -p 4000:80 --name web nginx
abc123def456

포트 매핑 확인:
$ docker ps
CONTAINER ID   IMAGE   COMMAND   CREATED   STATUS   PORTS                 NAMES
abc123def456   nginx   "..."     1 min     Up 1 min 0.0.0.0:4000->80/tcp  web

접근 테스트:
$ curl localhost:4000
<!DOCTYPE html>
<html>
<head>
<title>Welcome to nginx!</title>
...

또는 브라우저에서:
http://localhost:4000

네트워크 상태 확인:
$ netstat -tlnp | grep 4000
tcp6       0      0 :::4000                 :::*                    LISTEN      1234/docker-proxy

iptables 규칙 확인:
$ sudo iptables -t nat -L DOCKER
Chain DOCKER (2 references)
target     prot opt source               destination
DNAT       tcp  --  0.0.0.0/0            0.0.0.0/0            tcp dpt:4000 to:172.17.0.2:80
```