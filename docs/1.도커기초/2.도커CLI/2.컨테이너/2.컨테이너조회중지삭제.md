## 컨테이너 조회/중지/삭제

### 🔍 컨테이너 조회

### **[실행 중인 컨테이너들만 조회]**

```bash
$ docker ps
```

**`ps`** : **process status**의 약자

### **docker ps 출력 분석**

```bash
출력 예시:
CONTAINER ID   IMAGE     COMMAND                  CREATED         STATUS         PORTS                  NAMES
abc123def456   nginx     "/docker-entrypoint.…"   10 minutes ago  Up 10 minutes  0.0.0.0:4000->80/tcp   web-server
def456abc123   mysql:8.0 "docker-entrypoint.s…"   5 minutes ago   Up 5 minutes   3306/tcp, 33060/tcp    database

각 컬럼 상세 설명:
- CONTAINER ID: 컨테이너 고유 식별자 (12자리 축약형)
- IMAGE: 컨테이너가 사용하는 이미지
- COMMAND: 컨테이너에서 실행 중인 주 명령어
- CREATED: 컨테이너 생성 시점 (실행 시작 시점 아님)
- STATUS: 현재 실행 상태와 지속 시간
- PORTS: 포트 매핑 정보
- NAMES: 컨테이너 이름 (--name으로 지정하거나 자동 생성)
```

### **STATUS 상태 종류**

```bash
주요 STATUS 패턴:
Up 10 minutes              *# 10분 전부터 실행 중*
Up 2 hours                 *# 2시간 전부터 실행 중*
Up 3 days                  *# 3일 전부터 실행 중*
Up About an hour           *# 약 1시간 전부터 실행 중*

Restarting (1) 30 seconds ago    *# 30초 전부터 재시작 중 (1번째 시도)*
Up 2 minutes (healthy)           *# 헬스체크 통과하여 정상 실행 중*
Up 5 minutes (unhealthy)         *# 헬스체크 실패했지만 실행 중*`
```

### **PORTS 정보 해석**

```bash
포트 표시 형태:
0.0.0.0:4000->80/tcp       *# 모든 인터페이스의 4000 포트 → 컨테이너 80 포트*
127.0.0.1:3306->3306/tcp   *# 로컬호스트의 3306 포트 → 컨테이너 3306 포트*
80/tcp                     *# 컨테이너 80 포트 노출 (호스트 매핑 없음)*
8080/tcp, 9090/tcp         *# 여러 포트 노출*
:::8080->8080/tcp          *# IPv6 포함 매핑*
```

### 🔍 모든 컨테이너 조회

### **[모든 컨테이너 조회 (작동 중인 컨테이너 + 작동을 멈춘 컨테이너)]**

```bash
$ docker ps -a
```

- **`a`** : **all**의 약자

### **docker ps -a 출력 분석**

```bash
출력 예시:
CONTAINER ID   IMAGE     COMMAND                  CREATED         STATUS                      PORTS                  NAMES
abc123def456   nginx     "/docker-entrypoint.…"   10 minutes ago  Up 10 minutes              0.0.0.0:4000->80/tcp   web-server
def456abc123   mysql:8.0 "docker-entrypoint.s…"   15 minutes ago  Exited (0) 5 minutes ago                          old-database
789abc123def   redis     "docker-entrypoint.s…"   1 hour ago      Exited (1) 45 minutes ago                         cache-server
456def789abc   ubuntu    "/bin/bash"              2 hours ago     Created                                           test-container

STATUS 상태 종류:
Up X minutes/hours/days     *# 실행 중*
Exited (0) X ago           *# 정상 종료 (exit code 0)*
Exited (1) X ago           *# 오류로 종료 (exit code 1)*
Exited (125) X ago         *# Docker 내부 오류*
Exited (126) X ago         *# 실행 권한 없음*
Exited (127) X ago         *# 명령어를 찾을 수 없음*
Created                    *# 생성됨 (아직 시작되지 않음)*
Restarting                 *# 재시작 중*
Paused                     *# 일시정지*
Dead                       *# 데드 상태 (복구 불가)*
```

### **유용한 조회 옵션들**

```bash
추가 조회 옵션들:

최근 N개 컨테이너만 표시:
$ docker ps -n 5          *# 최근 5개만*

컨테이너 크기 정보 포함:
$ docker ps -s
CONTAINER ID   IMAGE   COMMAND   CREATED   STATUS   PORTS   NAMES   SIZE
abc123def456   nginx   "..."     10 min    Up 10    80/tcp  web     2MB (virtual 142MB)

컨테이너 ID만 출력:
$ docker ps -q            *# 실행 중인 것만*
$ docker ps -aq           *# 모든 컨테이너*

특정 조건으로 필터링:
$ docker ps --filter "status=exited"        *# 종료된 컨테이너만*
$ docker ps --filter "name=web"             *# 이름에 web 포함*
$ docker ps --filter "ancestor=nginx"       *# nginx 이미지 기반만*
$ docker ps --filter "expose=80"            *# 80 포트 노출한 것만*

커스텀 포맷으로 출력:
$ docker ps --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"
NAMES         STATUS          PORTS
web-server    Up 10 minutes   0.0.0.0:4000->80/tcp
database      Up 5 minutes    3306/tcp

JSON 형태로 출력:
$ docker ps --format json
{"Command":"\"/docker-entrypoint.sh nginx -g 'daemon off;'\"","CreatedAt":"2023-11-15 10:30:45 +0900 KST",...}
```

### ⏹️ 컨테이너 중지

```bash
$ docker stop 컨테이너명[또는 컨테이너 ID]
$ docker kill 컨테이너명[또는 컨테이너 ID]
```

집에 있는 컴퓨터로 비유하자면 **`stop`은 시스템 종료 버튼을 통해 정상적으로 컴퓨터를 종료하는 걸 의미하고, `kill`은 본체 버튼을 눌러 무식하게 종료하는 걸 의미**해요.

### **docker stop vs docker kill 상세 차이**

```
docker stop (정상 종료):
┌─────────────────────────────────────────────────┐
│ 1. SIGTERM 신호 전송                            │
│    - 프로세스에게 "정상 종료하세요" 요청         │
│    - 애플리케이션이 정리 작업 수행 가능          │
│    - 파일 저장, 연결 종료, 캐시 정리 등         │
│                                                │
│ 2. Grace Period 대기 (기본 10초)                │
│    - 애플리케이션이 정리 작업 완료할 시간 제공   │
│    - docker stop -t 30 으로 시간 조정 가능      │
│                                                │
│ 3. SIGKILL 신호 전송 (응답 없을 시)             │
│    - 강제 종료 (마지막 수단)                    │
└─────────────────────────────────────────────────┘

docker kill (강제 종료):
┌─────────────────────────────────────────────────┐
│ 1. SIGKILL 신호 즉시 전송                       │
│    - 프로세스 즉시 강제 종료                    │
│    - 정리 작업 없이 바로 종료                   │
│    - 데이터 손실 가능성 있음                    │
└─────────────────────────────────────────────────┘
```

### **신호 처리 상세**

```
Linux 신호 체계:
SIGTERM (15):
- Terminate 신호
- 프로그램이 신호를 받고 정상 종료 처리 가능
- 신호 핸들러로 커스텀 종료 로직 실행 가능

SIGKILL (9):
- Kill 신호
- 운영체제가 프로세스를 즉시 강제 종료
- 프로그램이 신호를 무시하거나 처리할 수 없음
- 마지막 수단으로만 사용

실제 예시:
$ docker stop web-server
web-server

내부 동작:
1. 컨테이너 내 PID 1 프로세스에 SIGTERM 전송
2. nginx가 신호 받고 워커 프로세스들 정리
3. 클라이언트 연결 정상 종료 처리
4. 10초 후 응답 없으면 SIGKILL 전송

$ docker kill web-server  
web-server

내부 동작:
1. 컨테이너 내 PID 1 프로세스에 SIGKILL 즉시 전송
2. nginx 프로세스 즉시 강제 종료
3. 클라이언트 연결 갑자기 끊김
```

### **언제 어떤 방법을 사용할까?**

```
docker stop 사용 권장:
✅ 웹서버 (nginx, apache)
✅ 데이터베이스 (mysql, postgres)
✅ 애플리케이션 서버
✅ 일반적인 모든 상황

docker kill 사용 경우:
⚠️ docker stop이 응답하지 않을 때
⚠️ 프로세스가 SIGTERM을 무시할 때
⚠️ 긴급하게 즉시 중지해야 할 때
⚠️ 무한루프에 빠진 프로세스

실무 예시:
$ docker stop database
*# 30초 기다렸는데 응답 없음*
$ docker kill database    *# 강제 종료*
```

### **중지 시간 조정**

```bash
Grace Period 조정:
$ docker stop -t 30 database    *# 30초 대기*
$ docker stop -t 60 database    *# 60초 대기*
$ docker stop -t 0 database     *# 즉시 SIGKILL (kill과 동일)*

여러 컨테이너 동시 중지:
$ docker stop web database cache
$ docker stop $(docker ps -q)   *# 실행 중인 모든 컨테이너*

병렬 중지 (더 빠름):
$ docker ps -q | xargs -P 4 docker stop
*# -P 4: 최대 4개 컨테이너 동시 중지*
```

### 🗑️ 컨테이너 삭제

### **[중지되어 있는 특정 컨테이너 삭제]**

```bash
$ docker rm 컨테이너명[또는 컨테이너 ID]
```

**실행 중인 컨테이너는 중지한 후에만 삭제가 가능해요.**

### **삭제 과정 상세**

```bash
컨테이너 삭제 과정:
1. 컨테이너 상태 확인:
   - 실행 중이면 오류 반환
   - 중지된 상태여야 삭제 가능

2. 파일시스템 정리:
   - 컨테이너 쓰기 레이어 삭제
   - 로그 파일 삭제
   - 임시 파일 정리

3. 네트워크 연결 해제:
   - 가상 네트워크 인터페이스 제거
   - 포트 매핑 해제
   - 브릿지 연결 해제

4. 메타데이터 삭제:
   - 컨테이너 정보 삭제
   - 이름 예약 해제

예시:
$ docker rm web-server
web-server

$ docker rm abc123def456   *# ID로도 가능*
abc123def456

$ docker rm abc1           *# 부분 ID로도 가능*
abc1
```

### **삭제 실패 케이스**

```bash
실행 중인 컨테이너 삭제 시도:
$ docker rm web-server
Error response from daemon: You cannot remove a running container abc123def456. Stop the container before attempting removal or force remove

해결 방법:
1. 정상적인 방법:
$ docker stop web-server
$ docker rm web-server

2. 한 번에 처리:
$ docker stop web-server && docker rm web-server
```

### 💪 실행되고 있는 특정 컨테이너 삭제

### **[실행되고 있는 특정 컨테이너 삭제]**

```bash
$ docker rm -f 컨테이너명[또는 컨테이너 ID]
```

### **f 옵션 (force) 동작**

```bash
강제 삭제 과정:
$ docker rm -f web-server

내부 동작:
1. docker kill web-server  (SIGKILL 전송)
2. docker rm web-server    (컨테이너 삭제)

주의사항:
⚠️ 데이터 손실 가능성
⚠️ 정상적인 종료 과정 생략
⚠️ 클라이언트 연결 갑작스런 종료
⚠️ 파일 정합성 문제 가능

안전한 대안:
$ docker stop web-server && docker rm web-server
```

### 🧹 중지되어 있는 모든 컨테이너 삭제

### **[중지되어 있는 모든 컨테이너 삭제]**

```bash
$ docker rm $(docker ps -qa)
```

### **명령어 분해 분석**

```bash
docker ps -qa 분석:
- docker ps: 컨테이너 목록 조회
- -q: quiet 모드 (ID만 출력)
- -a: all (모든 컨테이너, 중지된 것 포함)

실행 과정:
1. docker ps -qa 실행:
   abc123def456
   def456abc123
   789abc123def

2. $() 구문으로 결과를 인수로 전달:
   docker rm abc123def456 def456abc123 789abc123def

3. 각 컨테이너 삭제 시도:
   - 중지된 컨테이너: 삭제 성공
   - 실행 중인 컨테이너: 삭제 실패 (오류 메시지)
```

### **더 안전한 방법들**

```bash
중지된 컨테이너만 삭제:
$ docker container prune
WARNING! This will remove all stopped containers.
Are you sure you want to continue? [y/N] y

특정 조건으로 삭제:
$ docker container prune --filter "until=24h"     *# 24시간 이전 컨테이너*
$ docker container prune --filter "label!=keep"   *# keep 라벨 없는 컨테이너*

확인 없이 삭제:
$ docker container prune -f

중지된 컨테이너만 선별 삭제:
$ docker rm $(docker ps -q --filter "status=exited")
```

### 💥 실행되고 있는 모든 컨테이너 삭제

### **[실행되고 있는 모든 컨테이너 삭제]**

```bash
$ docker rm -f $(docker ps -qa)
```

### **위험성과 주의사항**

```
⚠️ 매우 위험한 명령어!

영향:
- 모든 실행 중인 컨테이너 강제 종료
- 모든 중지된 컨테이너 삭제
- 진행 중인 작업 모두 중단
- 데이터 손실 가능성

사용 전 확인사항:
1. 중요한 데이터가 컨테이너에 있는지 확인
2. 백업이 되어 있는지 확인
3. 다른 사람이 사용 중인 컨테이너는 없는지 확인

더 안전한 대안:
$ docker ps                              *# 실행 중인 컨테이너 확인*
$ docker stop $(docker ps -q)           *# 모든 컨테이너 정상 중지*
$ docker rm $(docker ps -qa)            *# 모든 컨테이너 삭제*
```

### 🛠️ 유용한 관리 명령어들

### **선택적 삭제**

```bash
이름 패턴으로 삭제:
$ docker rm $(docker ps -aq --filter "name=test")    *# test가 포함된 이름*
$ docker rm $(docker ps -aq --filter "name=^/test")  *# test로 시작하는 이름*

이미지별 삭제:
$ docker rm $(docker ps -aq --filter "ancestor=nginx")

상태별 삭제:
$ docker rm $(docker ps -aq --filter "status=exited")
$ docker rm $(docker ps -aq --filter "status=created")

시간 기준 삭제:
$ docker ps -aq --filter "created>2023-11-01" | xargs docker rm
```

### **일괄 관리 스크립트**

```bash
개발환경 완전 정리:
*#!/bin/bash*
echo "모든 컨테이너 중지 중..."
docker stop $(docker ps -q) 2>/dev/null

echo "모든 컨테이너 삭제 중..."
docker rm $(docker ps -aq) 2>/dev/null

echo "사용하지 않는 이미지 삭제 중..."
docker image prune -f

echo "사용하지 않는 네트워크 삭제 중..."
docker network prune -f

echo "사용하지 않는 볼륨 삭제 중..."
docker volume prune -f

echo "정리 완료!"
```

### **시스템 모니터링**

```bash
리소스 사용량 확인:
$ docker stats                    *# 실시간 리소스 모니터링*
$ docker stats --no-stream       *# 한 번만 출력*

컨테이너 상세 정보:
$ docker inspect web-server      *# JSON 형태 상세 정보*
$ docker logs web-server         *# 컨테이너 로그*
$ docker logs -f web-server      *# 실시간 로그 추적*

시스템 전체 정보:
$ docker system df               *# 디스크 사용량*
$ docker system events          *# 실시간 이벤트 모니터링*
```