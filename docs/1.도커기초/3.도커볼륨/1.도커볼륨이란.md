## Docker Volume

### 🚨 컨테이너가 가진 문제점

Docker를 활용하면 특정 프로그램을 컨테이너로 띄울 수 있어요. 이 프로그램에 기능이 추가되면 새로운 이미지를 만들어서 컨테이너를 실행시켜야 해요. 이때, Docker는 기존 컨테이너에서 변경된 부분을 수정하지 않고, 새로운 컨테이너를 만들어서 통째로 갈아끼우는 방식으로 교체를 해요. 이게 효율적이라고 생각했던 거죠.

이런 특징 때문에 기존 컨테이너를 새로운 컨테이너로 교체하면, **기존 컨테이너 내부에 있던 데이터도 같이 삭제돼요**. 만약 이 컨테이너가 MySQL을 실행시키는 컨테이너였다면 MySQL에 저장된 데이터도 같이 삭제돼버려요.

### **문제점 시나리오**

```
문제 상황 예시:
1. MySQL 컨테이너 실행
$ docker run -d --name database mysql:8.0

2. 중요한 데이터 입력
$ docker exec -it database mysql -u root -p
mysql> CREATE DATABASE myapp;
mysql> USE myapp;
mysql> CREATE TABLE users (id INT, name VARCHAR(50));
mysql> INSERT INTO users VALUES (1, 'Alice'), (2, 'Bob');

3. 컨테이너 업데이트 필요 (새 버전 사용)
$ docker stop database
$ docker rm database
$ docker run -d --name database mysql:8.1  *# 새 버전*

4. 결과: 모든 데이터 손실 💥
mysql> SHOW DATABASES;
*# myapp 데이터베이스가 사라짐!*
```

따라서 컨테이너 내부에 저장된 데이터가 삭제되면 안 되는 경우에는 **볼륨(Volume)**이라는 개념을 활용해야 해요.

### 📦 Docker Volume(도커 볼륨)이란?

- 도커의 볼륨(Volume)이란 **도커 컨테이너에서 데이터를 영속적으로 저장하기 위한 방법**이에요. 볼륨(Volume)은 컨테이너 자체의 저장 공간을 사용하지 않고, 호스트 자체의 저장 공간을 공유해서 사용하는 형태예요.

### **Volume 동작 원리**

```
Volume 없이 (문제 상황):
┌─────────────────────────────────────────────────┐
│              Host OS                            │
│  ┌─────────────────────────────────────────────┐│
│  │          Container                          ││
│  │  ┌─────────────────────────────────────────┐││
│  │  │ Application + Data                      │││
│  │  │ ┌─────────────────────────────────────┐ │││
│  │  │ │ 🗃️ 중요한 데이터                     │ │││
│  │  │ │ (컨테이너와 함께 삭제됨!)           │ │││
│  │  │ └─────────────────────────────────────┘ │││
│  │  └─────────────────────────────────────────┘││
│  └─────────────────────────────────────────────┘│
└─────────────────────────────────────────────────┘

Volume 사용 (해결책):
┌─────────────────────────────────────────────────┐
│              Host OS                            │
│  ┌─────────────────────────────────────────────┐│
│  │ 🗃️ Host Directory                           ││
│  │ /var/lib/mysql                              ││
│  │ (데이터 영구 보존!)                          ││
│  └─────────────────────────────────────────────┘│
│                     ↕ Volume Mount             │
│  ┌─────────────────────────────────────────────┐│
│  │          Container                          ││
│  │  ┌─────────────────────────────────────────┐││
│  │  │ Application                             │││
│  │  │ /var/lib/mysql → Host Directory 연결    │││
│  │  └─────────────────────────────────────────┘││
│  └─────────────────────────────────────────────┘│
└─────────────────────────────────────────────────┘
```

### 🔧 볼륨(Volume)을 사용하는 명령어

```bash
$ docker run -v [호스트의 디렉토리 절대경로]:[컨테이너의 디렉토리 절대경로] [이미지명]:[태그명]
```

### **v 옵션 상세 분석**

bash

```
v 옵션 구조:
-v [호스트경로]:[컨테이너경로]:[옵션]
예시:
-v /home/user/data:/var/lib/mysql
-v /Users/john/webroot:/var/www/html
-v /tmp/logs:/app/logs:ro *# :ro = 읽기 전용*
옵션들:
:ro - read-only (읽기 전용)
:rw - read-write (읽기/쓰기, 기본값)
:z - SELinux 컨텍스트 설정
:Z - SELinux private 컨텍스트
```

### **호스트 디렉토리 존재 여부에 따른 동작**

**`[호스트의 디렉토리 절대 경로]`에 디렉토리가 이미 존재할 경우**, 호스트의 디렉토리가 컨테이너의 디렉토리를 덮어씌워요.

**`[호스트의 디렉토리 절대 경로]`에 디렉토리가 존재하지 않을 경우**, 호스트의 디렉토리 절대 경로에 디렉토리를 새로 만들고 컨테이너의 디렉토리에 있는 파일들을 호스트의 디렉토리로 복사해와요.

```bash
케이스 1: 호스트 디렉토리가 이미 존재
*# 호스트에 /home/user/mysql-data 디렉토리가 있고 파일들이 있음*
$ ls /home/user/mysql-data
existing-file.sql  config.cnf

$ docker run -v /home/user/mysql-data:/var/lib/mysql mysql:8.0
*# 결과: 호스트의 기존 파일들이 컨테이너에서 보임# 컨테이너의 /var/lib/mysql 기본 내용은 숨겨짐*

케이스 2: 호스트 디렉토리가 존재하지 않음
$ ls /home/user/new-mysql-data
ls: cannot access '/home/user/new-mysql-data': No such file or directory

$ docker run -v /home/user/new-mysql-data:/var/lib/mysql mysql:8.0
*# 결과: /home/user/new-mysql-data 디렉토리 자동 생성# 컨테이너의 /var/lib/mysql 내용이 호스트로 복사됨*

$ ls /home/user/new-mysql-data
auto.cnf  ca-key.pem  ca.pem  ib_logfile0  ib_logfile1  ibdata1  mysql/  ...
```

### 📁 Volume의 종류

### **1. Bind Mount (바인드 마운트)**

```bash
호스트의 특정 경로를 직접 지정:
$ docker run -v /home/user/data:/app/data nginx

특징:
✅ 호스트 경로를 직접 제어 가능
✅ 호스트에서 파일 직접 편집 가능
⚠️ 호스트 시스템에 의존적
⚠️ 경로가 절대경로여야 함

실습 예시:
$ mkdir -p /Users/$(whoami)/web-content
$ echo "<h1>Hello from Host!</h1>" > /Users/$(whoami)/web-content/index.html
$ docker run -d -p 8080:80 -v /Users/$(whoami)/web-content:/usr/share/nginx/html nginx
*# http://localhost:8080 접속하면 호스트의 HTML 파일이 보임*
```

### **2. Named Volume (네임드 볼륨)**

```bash
Docker가 관리하는 볼륨:
$ docker volume create my-data
$ docker run -v my-data:/app/data nginx

특징:
✅ Docker가 위치 자동 관리
✅ 플랫폼 독립적
✅ 백업/복원 용이
⚠️ 호스트에서 직접 접근 어려움

볼륨 관리:
$ docker volume ls                    *# 볼륨 목록*
$ docker volume inspect my-data       *# 볼륨 상세 정보*
$ docker volume rm my-data           *# 볼륨 삭제*
```

### **3. Anonymous Volume (익명 볼륨)**

```bash
이름 없는 임시 볼륨:
$ docker run -v /app/data nginx

특징:
✅ 간단한 임시 데이터 보존
⚠️ 관리 어려움
⚠️ 컨테이너 삭제 시 함께 삭제됨
```

### 💾 실제 Volume 사용 예시

### **MySQL 데이터 영속화**

```bash
MySQL 데이터를 호스트에 보존:
$ mkdir -p ~/mysql-data
$ docker run -d \
  --name mysql-server \
  -e MYSQL_ROOT_PASSWORD=mypassword \
  -e MYSQL_DATABASE=testdb \
  -v ~/mysql-data:/var/lib/mysql \
  -p 3306:3306 \
  mysql:8.0

데이터 입력:
$ docker exec -it mysql-server mysql -u root -p
mysql> USE testdb;
mysql> CREATE TABLE users (id INT, name VARCHAR(50));
mysql> INSERT INTO users VALUES (1, 'Alice'), (2, 'Bob');
mysql> SELECT * FROM users;

컨테이너 재시작해도 데이터 보존:
$ docker stop mysql-server
$ docker rm mysql-server
$ docker run -d \
  --name mysql-server-new \
  -e MYSQL_ROOT_PASSWORD=mypassword \
  -v ~/mysql-data:/var/lib/mysql \
  -p 3306:3306 \
  mysql:8.0

$ docker exec -it mysql-server-new mysql -u root -p
mysql> USE testdb;
mysql> SELECT * FROM users;
+------+-------+
| id   | name  |
+------+-------+
|    1 | Alice |
|    2 | Bob   |
+------+-------+
*# 데이터가 그대로 보존됨!*
```

### Volume 모니터링 및 관리

### **Volume 정보 확인**

```bash
모든 볼륨 목록:
$ docker volume ls
DRIVER    VOLUME NAME
local     mysql-data
local     web-data
local     a1b2c3d4e5f6...

볼륨 상세 정보:
$ docker volume inspect mysql-data
[
    {
        "CreatedAt": "2023-11-15T10:30:45Z",
        "Driver": "local",
        "Labels": {},
        "Mountpoint": "/var/lib/docker/volumes/mysql-data/_data",
        "Name": "mysql-data",
        "Options": {},
        "Scope": "local"
    }
]

실제 저장 위치:
Linux: /var/lib/docker/volumes/[volume-name]/_data
macOS: ~/Library/Containers/com.docker.docker/Data/vms/0/volumes/
Windows: \\wsl$\docker-desktop-data\version-pack-data\community\docker\volumes\
```

### **컨테이너별 Volume 확인**

```bash
컨테이너의 마운트 정보:
$ docker inspect mysql-server | grep -A 10 "Mounts"
"Mounts": [
    {
        "Type": "bind",
        "Source": "/Users/john/mysql-data",
        "Destination": "/var/lib/mysql",
        "Mode": "",
        "RW": true,
        "Propagation": "rprivate"
    }
]

실행 중인 컨테이너의 볼륨:
$ docker ps --format "table {{.Names}}\t{{.Mounts}}"
NAMES           MOUNTS
mysql-server    /Users/john/mysql-data
web-server      /Users/john/web-files
```

### 🧹 Volume 정리 및 백업

### **사용하지 않는 Volume 정리**

```bash
사용하지 않는 볼륨 제거:
$ docker volume prune
WARNING! This will remove all local volumes not used by at least one container.
Are you sure you want to continue? [y/N] y

특정 볼륨 삭제:
$ docker volume rm mysql-data
Error: volume is in use - container abc123def456

강제 삭제 (컨테이너 먼저 삭제):
$ docker rm -f mysql-server
$ docker volume rm mysql-data
```

### **Volume 백업 및 복원**

```bash
볼륨 데이터 백업:
$ docker run --rm \
  -v mysql-data:/data \
  -v $(pwd):/backup \
  alpine tar czf /backup/mysql-backup.tar.gz -C /data .

볼륨 데이터 복원:
$ docker volume create mysql-data-restored
$ docker run --rm \
  -v mysql-data-restored:/data \
  -v $(pwd):/backup \
  alpine tar xzf /backup/mysql-backup.tar.gz -C /data

Bind Mount 백업 (더 간단):
$ tar czf mysql-backup.tar.gz -C ~/mysql-data .
$ tar xzf mysql-backup.tar.gz -C ~/mysql-data-restored
```

### 🎯 Volume 사용 베스트 프랙티스

### **용도별 권장사항**

```
데이터베이스 (MySQL, PostgreSQL, MongoDB):
✅ Named Volume 사용 권장
✅ 정기적인 백업 설정
✅ 복제본 볼륨 생성

로그 파일:
✅ Bind Mount로 호스트에 직접 저장
✅ 로그 로테이션 설정
✅ 분석 도구 연동 용이

개발 환경:
✅ Bind Mount로 코드 실시간 반영
✅ 호스트 에디터에서 직접 편집
✅ 빠른 개발 사이클

설정 파일:
✅ Bind Mount로 호스트에서 관리
✅ 버전 제어 시스템과 연동
✅ 환경별 설정 분리
```