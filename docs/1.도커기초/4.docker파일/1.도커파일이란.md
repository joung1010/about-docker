## Dockerfile이란?

### 🐳 Dockerfile의 필요성

Docker 이미지는 Docker Hub을 통해 다운받아서 사용할 수 있어요. 이 Docker 이미지들도 누군가 만들어서 Docker Hub에 올려놓은 것이죠. 그럼 도대체 이 Docker 이미지는 어떻게 만드는 걸까요?

**Dockerfile**이라는 걸 활용해서 Docker 이미지를 만들 수 있어요.

Docker Hub에 올려놓은 Docker 이미지가 아닌, 나만의 Docker 이미지를 만들고 싶을 수 있어요. 예를 들어, 내가 만든 Spring Boot 프로젝트가 있다고 하죠. 내가 만든 Spring Boot 프로젝트 자체를 Docker 이미지로 만들고 싶을 수 있어요. 이럴 때에도 Dockerfile을 활용하면 나만의 Docker 이미지를 만들 수 있게 돼요.

정리하자면, **Dockerfile**이란 **Docker 이미지를 만들게 해주는 파일**입니다.

### 📝 Dockerfile의 구조

```
Dockerfile의 역할:
┌─────────────────────────────────────────────────┐
│              Dockerfile                         │
│  ┌─────────────────────────────────────────────┐│
│  │ FROM ubuntu:20.04                           ││
│  │ RUN apt-get update                          ││
│  │ RUN apt-get install -y python3             ││
│  │ COPY app.py /app/                           ││
│  │ WORKDIR /app                               ││
│  │ CMD ["python3", "app.py"]                  ││
│  └─────────────────────────────────────────────┘│
└─────────────────────────────────────────────────┘
                        ↓ docker build
┌─────────────────────────────────────────────────┐
│               Custom Image                      │
│   (Ubuntu + Python + Your App)                 │
└─────────────────────────────────────────────────┘
                        ↓ docker run
┌─────────────────────────────────────────────────┐
│               Container                         │
│   (실행 중인 애플리케이션)                       │
└─────────────────────────────────────────────────┘
```

## FROM: 베이스 이미지 생성

### 🔧 의미

`FROM`은 베이스 이미지를 생성하는 역할을 해요. Docker 컨테이너를 **특정 초기 이미지**를 기반으로 추가적인 셋팅을 할 수 있어요. 여기서 얘기한 '특정 초기 이미지'가 곧 **베이스 이미지**예요.

조금 더 쉽게 설명해보겠어요.

우리가 윈도우 컴퓨터를 새로 사서 실행시켜보면 기본 프로그램들(인터넷, 그림판, 메모장 등)이 많이 깔려있어요. 베이스 이미지도 이와 똑같아요. 컨테이너를 새로 띄워서 미니 컴퓨터 환경을 구축할 때 기본 프로그램이 어떤 게 깔려있으면 좋겠는지 선택하는 옵션이라고 생각하면 돼요.

누군가는 JDK가 깔려있는 컴퓨터 환경이 셋팅되기를 바랄 수도 있고, 누군가는 Node가 깔려있는 컴퓨터 환경이 셋팅되기를 바랄 수도 있어요. 필요에 따라 베이스 이미지를 고르면 돼요.

### 📖 용법

```docker
*# 문법*
FROM [이미지명]
FROM [이미지명]:[태그명]
```

`태그명`을 적지 않으면 해당 이미지의 최신(latest) 버전을 사용해요.

### **베이스 이미지 선택 가이드**

```docker
용도별 베이스 이미지:

Java 개발:
FROM openjdk:17-jdk        *# JDK 17 포함*
FROM openjdk:21-jdk        *# JDK 21 포함*
FROM maven:3.8-openjdk-17  *# Maven + JDK 17*

Node.js 개발:
FROM node:18               *# Node.js 18 LTS*
FROM node:20-alpine        *# Node.js 20 + Alpine (경량)*

Python 개발:
FROM python:3.11           *# Python 3.11*
FROM python:3.11-slim      *# Python 3.11 경량화*

웹서버:
FROM nginx:alpine          *# Nginx + Alpine*
FROM httpd:2.4             *# Apache HTTP Server*

운영체제 기반:
FROM ubuntu:22.04          *# Ubuntu 22.04*
FROM alpine:3.18           *# Alpine Linux (매우 경량)*
FROM centos:7              *# CentOS 7*
```

## JDK 21 베이스 이미지로 컨테이너 띄워보기

### 1. Dockerfile 만들기

**Dockerfile**

```docker
*# JDK 21*
FROM openjdk:21-jdk
```

### **Dockerfile 작성 규칙**

```
Dockerfile 파일명 규칙:
✅ 정확한 파일명: Dockerfile (확장자 없음)
❌ 잘못된 예: dockerfile.txt, Dockerfile.docker

Dockerfile 위치:
- 프로젝트 루트 디렉토리에 위치
- docker build 명령어 실행 위치와 동일한 곳

내용 작성 규칙:
- 각 명령어는 새 줄에 작성
- *# 으로 주석 처리 가능*
- 대소문자 구분 없음 (관례적으로 대문자 사용)
```

### 2. Dockerfile을 기반으로 이미지 만들기

### **Dockerfile로 이미지(Image) 생성하는 문법**

```docker
*# docker build -t [이미지명]:[태그명] [Dockerfile이 존재하는 디렉토리 경로]*

$ docker build -t sample .
$ docker build -t sample:1.0 .
```

태그명을 적지 않으면 `latest`로 설정돼요.

```docker
$ docker build -t my-jdk21-server .
```

### **빌드 과정 상세**

```
이미지 빌드 과정:
$ docker build -t my-jdk21-server .

출력:
[+] Building 45.2s (5/5) FINISHED
 => [internal] load build definition from Dockerfile
 => => transferring dockerfile: 36B
 => [internal] load .dockerignore
 => => transferring context: 2B
 => [internal] load metadata for docker.io/library/openjdk:21-jdk
 => [1/1] FROM docker.io/library/openjdk:21-jdk
 => => resolve docker.io/library/openjdk:21-jdk:latest
 => => sha256:abc123... (manifest)
 => => sha256:def456... (config)
 => => extracting sha256:abc123...
 => exporting to image
 => => exporting layers
 => => writing image sha256:789ghi...
 => => naming to docker.io/library/my-jdk21-server:latest

빌드 단계:
1. Dockerfile 로드
2. 베이스 이미지 (openjdk:21-jdk) 다운로드
3. 레이어 생성
4. 최종 이미지 생성 및 태그 설정
```

### 3. 이미지를 기반으로 컨테이너 띄우기

```bash
$ docker run -d my-jdk21-server
```

### 4. 컨테이너 조회하기

```bash
$ docker ps *# 실행되고 있는 컨테이너가 없다.*
$ docker ps -a *# 확인해보니 컨테이너가 종료되어 있다.*
```

### **컨테이너가 종료되는 이유**

Docker의 컨테이너는 내부적으로 필요한 명령을 다 수행하면 컨테이너가 저절로 종료돼요.

```
컨테이너 생명주기:
1. 컨테이너 시작
2. 메인 프로세스(PID 1) 실행
3. 메인 프로세스 종료
4. 컨테이너 자동 종료

openjdk:21-jdk 이미지의 기본 동작:
- 베이스 이미지에 특별한 실행 명령이 없음
- bash 쉘이 시작되지만 인터랙티브 모드가 아니므로 즉시 종료
- 결과: 컨테이너가 바로 Exited 상태가 됨

해결 방법:
1. 지속적으로 실행될 명령어 추가
2. 인터랙티브 모드로 실행 (-it 옵션)
3. 백그라운드에서 계속 실행되는 프로세스 설정
```

### 5. 컨테이너 내부로 들어가서 JDK가 잘 깔렸는지 확인해보기

### **컨테이너가 계속 실행되도록 설정**

**Dockerfile**

```docker
FROM openjdk:21-jdk

ENTRYPOINT ["/bin/bash", "-c", "sleep 500"]
```

### **ENTRYPOINT 명령어 설명**

```docker
ENTRYPOINT vs CMD:
ENTRYPOINT: 컨테이너가 실행될 때 항상 실행되는 명령어
CMD: 기본 실행 명령어 (docker run 시 덮어쓰기 가능)

ENTRYPOINT ["/bin/bash", "-c", "sleep 500"] 의미:
- /bin/bash: bash 쉘 실행
- -c: 다음 문자열을 명령어로 실행
- sleep 500: 500초 동안 대기 (컨테이너를 계속 실행 상태로 유지)

다른 방법들:
ENTRYPOINT ["tail", "-f", "/dev/null"]  *# 무한 대기*
ENTRYPOINT ["sleep", "infinity"]        *# 무한 대기*
CMD ["bash"]                           *# bash 쉘 실행*
```

### **빌드 및 실행**

```bash
$ docker build -t my-jdk21-server . *# 이미지 빌드*
$ docker run -d my-jdk21-server *# 컨테이너 실행*
$ docker ps *# 실행 중인 컨테이너 조회*
$ docker exec -it [컨테이너 ID] bash *# 컨테이너 접속*

$ java -version *# JDK 설치되어 있는지 확인*
```

### **JDK 설치 확인**

```bash
컨테이너 내부에서 JDK 확인:
root@abc123def456:/*# java -version*
openjdk version "21.0.1" 2023-10-17
OpenJDK Runtime Environment (build 21.0.1+12-jvmci-23.1-b19)
OpenJDK 64-Bit Server VM (build 21.0.1+12-jvmci-23.1-b19, mixed mode, sharing)

root@abc123def456:/*# javac -version*
javac 21.0.1

root@abc123def456:/*# which java*
/usr/bin/java

root@abc123def456:/*# echo $JAVA_HOME*
/usr/lib/jvm/java-21-openjdk-amd64

간단한 Java 코드 테스트:
root@abc123def456:/*# echo 'public class Hello { public static void main(String[] args) { System.out.println("Hello Docker!"); } }' > Hello.java*
root@abc123def456:/*# javac Hello.java*
root@abc123def456:/*# java Hello*
Hello Docker!
```

## Node 베이스 이미지로 컨테이너 띄워보기

### **Dockerfile 만들기**

```docker
FROM node

ENTRYPOINT ["/bin/bash", "-c", "sleep 500"]
```

### **이미지 만들고 컨테이너 띄우기**

```bash
$ docker build -t my-node-server . *# 이미지 생성*
$ docker run -d my-node-server *# 이미지를 기반으로 컨테이너 생성*
$ docker ps *# 실행 중인 컨테이너 조회*
$ docker exec -it [컨테이너 ID] bash *# 컨테이너 접속*

$ node -v *# Node 설치되어 있는지 확인*
```

### **Node.js 환경 확인**

```bash
컨테이너 내부에서 Node.js 확인:
root@def456abc123:/*# node -v*
v20.9.0

root@def456abc123:/*# npm -v*
10.1.0

root@def456abc123:/*# which node*
/usr/local/bin/node

root@def456abc123:/*# which npm*
/usr/local/bin/npm

간단한 Node.js 코드 테스트:
root@def456abc123:/*# echo 'console.log("Hello Docker from Node.js!");' > hello.js*
root@def456abc123:/*# node hello.js*
Hello Docker from Node.js!

패키지 설치 테스트:
root@def456abc123:/*# npm init -y*
root@def456abc123:/*# npm install lodash*
root@def456abc123:/*# echo 'const _ = require("lodash"); console.log(_.reverse([1,2,3,4]));' > test.js*
root@def456abc123:/*# node test.js*
[ 4, 3, 2, 1 ]
```

### 🎯 Dockerfile 작성 팁

### **효율적인 베이스 이미지 선택**

```
이미지 크기 비교:
ubuntu:22.04        ~77MB
alpine:3.18         ~7MB
node:20             ~1.1GB
node:20-alpine      ~178MB
openjdk:21-jdk      ~688MB
openjdk:21-jdk-slim ~432MB

개발 환경 vs 프로덕션:
개발: 풀 버전 사용 (디버깅 도구 포함)
- FROM node:20
- FROM openjdk:21-jdk

프로덕션: 경량 버전 사용 (보안, 성능)
- FROM node:20-alpine
- FROM openjdk:21-jdk-slim
```

### **멀티스테이지 빌드 미리보기**

```docker
*# 빌드 스테이지*
FROM node:18 AS builder
WORKDIR /app
COPY package*.json ./
RUN npm install

*# 실행 스테이지*
FROM node:18-alpine
WORKDIR /app
COPY --from=builder /app/node_modules ./node_modules
COPY . .
CMD ["node", "index.js"]
```