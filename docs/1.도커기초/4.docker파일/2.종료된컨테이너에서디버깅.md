## Docker 컨테이너 디버깅과 생명주기 관리

### 🔍 Docker 디버깅의 근본적 문제

Docker를 사용하면 대부분의 코드가 컨테이너 내부에서 작동해요. 그러다보니 어떤 과정으로 처리됐는지, 잘 처리는 됐는지를 직접적으로 눈에 보이지 않아요. 이 때문에 Docker 학습에 어려움을 겪죠.

```
전통적인 개발 vs Docker 개발:

전통적인 방식:
개발자 PC에서 직접 실행 → 모든 과정이 눈에 보임
├── 파일 시스템 직접 접근 가능
├── 프로세스 상태 직접 확인 가능
├── 로그 파일 실시간 확인 가능
└── 디버깅 도구 자유롭게 사용 가능

Docker 방식:
컨테이너 내부에서 실행 → 블랙박스처럼 보임
├── 컨테이너 내부가 격리되어 있음
├── 프로세스가 컨테이너 안에서만 보임
├── 파일 시스템이 분리되어 있음
└── 디버깅을 위한 별도 접근 방법 필요
```

### 🛠️ 기존 디버깅 방법들

이를 해결하기 위해 우리는 2가지 방법을 이미 익혔어요.

### **1. `docker logs`를 활용해 컨테이너 로그 확인하기**

```
로그 기반 디버깅:
$ docker logs [컨테이너 ID]
$ docker logs -f [컨테이너 ID]        *# 실시간 추적*
$ docker logs --tail 50 [컨테이너 ID] *# 마지막 50줄만*
$ docker logs --since 10m [컨테이너 ID] *# 10분 전부터*

장점:
✅ 컨테이너 상태와 무관하게 사용 가능
✅ 애플리케이션 실행 과정 추적 가능
✅ 에러 메시지 확인 가능

한계:
❌ 애플리케이션이 로그를 출력하지 않으면 정보 부족
❌ 파일 시스템 상태 확인 불가
❌ 대화형 디버깅 불가
```

### **2. `docker exec -it`를 활용해 컨테이너 내부에 직접 들어가보기**

```
대화형 디버깅:
$ docker exec -it [컨테이너 ID] bash
$ docker exec -it [컨테이너 ID] sh     *# bash 없는 경우*

장점:
✅ 파일 시스템 직접 탐색 가능
✅ 프로세스 상태 실시간 확인
✅ 명령어 직접 실행 및 테스트 가능
✅ 설정 파일 수정 및 확인 가능

한계:
❌ 실행 중인 컨테이너에만 사용 가능
❌ 종료된 컨테이너는 접근 불가
```

### ⚠️ 핵심 문제: 컨테이너 자동 종료

위 방법 중 `docker exec -it`은 실행 중인 컨테이너에만 쓸 수 있는 명령어예요. 종료된 컨테이너는 아래와 같은 에러가 발생해요.

```bash
종료된 컨테이너 접근 시도:
$ docker exec -it abc123def456 bash
Error response from daemon: Container abc123def456 is not running

컨테이너 상태 확인:
$ docker ps -a
CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS                     PORTS   NAMES
abc123def456   my-app    "..."     1 min     Exited (0) 30 seconds ago          my-container
```

하지만 이미지를 만들면서 컨테이너를 실행시켜보면, 컨테이너의 특성상 명령어 처리가 다 끝나는대로 컨테이너가 종료돼요. 그러다보니 내부적으로 어떻게 컨테이너가 형성됐는지 디버깅을 하는데 어려움을 겪어요.

### **컨테이너 자동 종료 원리**

```bash
컨테이너 생명주기:
1. docker run 실행
2. 컨테이너 생성 및 시작
3. PID 1 프로세스 실행 (ENTRYPOINT/CMD)
4. PID 1 프로세스 종료
5. 컨테이너 자동 종료 (Exited 상태)

예시 - 기본 Ubuntu 컨테이너:
$ docker run ubuntu
*# bash가 실행되지만 인터랙티브 모드가 아니므로 즉시 종료# 결과: 컨테이너가 바로 Exited 상태*

예시 - 명령어 실행 후 종료:
$ docker run ubuntu echo "Hello World"
Hello World
*# echo 명령어 실행 완료 후 컨테이너 자동 종료*
```

### 💡 해결책: 컨테이너를 계속 실행 상태로 유지

**어떻게 해야 할까?**

**Dockerfile**

```bash
FROM openjdk:17-jdk

...

ENTRYPOINT ["/bin/bash", "-c", "sleep 500"] # 500초 동안 시스템을 일시정지 시키는 명령어
```

위 명령어를 추가함으로써 컨테이너가 바로 종료되는 걸 막을 수 있어요. 그런 뒤에 `docker exec -it`를 활용해 컨테이너 내부에 직접 들어가서 디버깅을 하면 돼요.

### **다양한 컨테이너 유지 방법들**

```bash
방법 1: sleep 명령어
ENTRYPOINT ["/bin/bash", "-c", "sleep 500"]
ENTRYPOINT ["sleep", "infinity"]            *# 무한 대기*

방법 2: tail 명령어
ENTRYPOINT ["tail", "-f", "/dev/null"]      *# 무한 대기*

방법 3: bash 쉘 유지
ENTRYPOINT ["/bin/bash"]                    *# bash 쉘만 실행*
CMD ["bash"]                               *# 기본 명령어로 bash 설정*

방법 4: 실제 서비스 실행 (프로덕션용)
ENTRYPOINT ["java", "-jar", "app.jar"]     *# 애플리케이션 실행*
CMD ["nginx", "-g", "daemon off;"]         *# 웹서버 실행*
```

### **각 방법의 용도**

```bash
개발/디버깅 용도:
sleep infinity    - 가장 단순, 리소스 사용 최소
tail -f /dev/null - sleep과 유사하지만 다른 접근법
bash             - 쉘 환경이 필요한 경우

테스트 용도:
sleep [시간]      - 일정 시간 후 자동 종료 원하는 경우

프로덕션 용도:
실제 애플리케이션 - 서비스가 지속적으로 실행되어야 하는 경우
```

### 🔧 실제 디버깅 워크플로우

### **1. 디버깅용 이미지 빌드**

```bash
Dockerfile (디버깅 버전):
FROM openjdk:17-jdk

*# 애플리케이션 코드 복사*
COPY myapp.jar /app/myapp.jar

*# 작업 디렉토리 설정*
WORKDIR /app

*# 컨테이너를 계속 실행 상태로 유지*
ENTRYPOINT ["sleep", "infinity"]

빌드:
$ docker build -t myapp-debug .
```

### **2. 컨테이너 실행 및 디버깅**

```bash
컨테이너 실행:
$ docker run -d --name myapp-container myapp-debug
abc123def456

상태 확인:
$ docker ps
CONTAINER ID   IMAGE        COMMAND             CREATED   STATUS    PORTS   NAMES
abc123def456   myapp-debug  "sleep infinity"    1 min     Up 1 min          myapp-container

컨테이너 접속:
$ docker exec -it myapp-container bash
root@abc123def456:/app*#* 

디버깅 작업:
root@abc123def456:/app*# ls -la*
root@abc123def456:/app*# java -version*
root@abc123def456:/app*# java -jar myapp.jar  # 수동으로 애플리케이션 실행*
root@abc123def456:/app*# cat /etc/hosts       # 네트워크 설정 확인*
root@abc123def456:/app*# ps aux               # 프로세스 확인*
```

### **3. 프로덕션 이미지로 전환**

```bash
Dockerfile (프로덕션 버전):
FROM openjdk:17-jdk

COPY myapp.jar /app/myapp.jar
WORKDIR /app

*# 실제 애플리케이션 실행*
ENTRYPOINT ["java", "-jar", "myapp.jar"]

빌드:
$ docker build -t myapp-prod .
$ docker run -d -p 8080:8080 myapp-prod
```

### 🛡️ 고급 디버깅 기법

### **1. 멀티스테이지 빌드로 디버깅 스테이지 분리**

```bash
*# 빌드 스테이지*
FROM openjdk:17-jdk AS build
COPY . /src
WORKDIR /src
RUN ./gradlew build

*# 디버깅 스테이지*
FROM openjdk:17-jdk AS debug
COPY --from=build /src/build/libs/app.jar /app/app.jar
WORKDIR /app
ENTRYPOINT ["sleep", "infinity"]

*# 프로덕션 스테이지*
FROM openjdk:17-jdk-slim AS production
COPY --from=build /src/build/libs/app.jar /app/app.jar
WORKDIR /app
ENTRYPOINT ["java", "-jar", "app.jar"]

사용법:
$ docker build --target debug -t myapp-debug .    # 디버깅용
$ docker build --target production -t myapp .     # 프로덕션용
```

### **2. 볼륨 마운트로 실시간 디버깅**

```bash
개발 중인 코드를 실시간으로 컨테이너에 반영:
$ docker run -d \
  --name dev-container \
  -v $(pwd)/src:/app/src \
  -v $(pwd)/logs:/app/logs \
  myapp-debug

코드 변경 사항 실시간 확인:
$ docker exec -it dev-container bash
root@abc123def456:/app*# # 호스트에서 변경한 파일이 실시간으로 반영됨*
```

### **3. 네트워크 디버깅**

```bash
네트워크 연결 상태 확인:
$ docker exec -it myapp-container netstat -tlnp
$ docker exec -it myapp-container curl localhost:8080
$ docker exec -it myapp-container ping google.com

컨테이너 간 네트워크 테스트:
$ docker network create test-network
$ docker run -d --network test-network --name web nginx
$ docker run -it --network test-network --name client alpine
/ *# wget -qO- http://web:80*
```

### **4. 로그와 함께 디버깅**

```bash
로그와 대화형 디버깅 동시 사용:
터미널 1: $ docker logs -f myapp-container
터미널 2: $ docker exec -it myapp-container bash

실시간으로 로그를 보면서 컨테이너 내부에서 명령어 실행
```

### 📋 디버깅 체크리스트

```bash
Docker 디버깅 단계:
□ 1. docker logs로 기본 로그 확인
□ 2. docker ps -a로 컨테이너 상태 확인
□ 3. sleep/tail로 컨테이너 실행 상태 유지
□ 4. docker exec -it로 컨테이너 내부 접속
□ 5. 파일 시스템, 프로세스, 네트워크 상태 확인
□ 6. 애플리케이션 수동 실행으로 동작 확인
□ 7. 문제 해결 후 프로덕션 이미지로 전환
```