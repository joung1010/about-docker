## WORKDIR : 작업 디렉토리를 지정

### 의미

`WORKDIR`으로 작업 디렉터리를 전환하면 그 이후에 등장하는 모든 `RUN`, `CMD`, `ENTRYPOINT`, `COPY`, `ADD` 명령문은 해당 디렉터리를 기준으로 실행돼요. 작업 디렉터리를 굳이 지정해주는 이유는 컨테이너 내부의 폴더를 깔끔하게 관리하기 위해서예요. 컨테이너도 미니 컴퓨터와 같기 때문에 `Dockerfile`을 통해 생성되는 파일들을 특정 폴더에 정리해두는 것이 추후에 관리가 쉬워요. 만약 `WORKDIR`을 쓰지 않으면 컨테이너 내부에 존재하는 기존 파일들과 뒤섞여버려요.

### 사용법

```docker
*# 문법*
WORKDIR [작업 디렉토리로 사용할 절대 경로]

*# 예시*
WORKDIR /usr/src/app
```

### **WORKDIR 동작 원리**

```
WORKDIR의 역할:
1. 지정된 디렉토리로 이동 (cd 명령어와 유사)
2. 디렉토리가 없으면 자동 생성
3. 이후 모든 명령어의 기준점이 됨
4. 컨테이너 실행 시 기본 작업 디렉토리가 됨

영향을 받는 명령어들:
- RUN: 해당 디렉토리에서 명령어 실행
- COPY/ADD: 대상 경로의 기준점
- CMD/ENTRYPOINT: 실행 시 작업 디렉토리
```

## 예제

### 1. app.txt, src, config.json 파일 만들기

```bash
프로젝트 구조 준비:
$ mkdir workdir-example
$ cd workdir-example
$ echo "Hello from app!" > app.txt
$ echo '{"name": "myapp"}' > config.json
$ mkdir src
$ echo "console.log('Hello');" > src/index.js
$ ls -la
drwxr-xr-x  . 
drwxr-xr-x  ..
-rw-r--r--  app.txt
-rw-r--r--  config.json
drwxr-xr-x  src/
```

### 2. WORKDIR을 안 썼을 때

`WORKDIR`을 안 썼을 때 파일이 어떻게 구성되는지 먼저 확인해보죠.

**Dockerfile**

docker

```docker
FROM ubuntu

COPY ./ ./

ENTRYPOINT ["/bin/bash", "-c", "sleep 500"] # 디버깅용 코드
```

```bash
$ docker build -t my-server .
$ docker run -d my-server
$ docker exec -it [Container ID] bash

$ ls
```

### **WORKDIR 없을 때 결과**

```bash
컨테이너 내부 파일 구조:
root@abc123def456:/*# ls -la*
total 72
drwxr-xr-x   1 root root 4096 Nov 15 10:30 .
drwxr-xr-x   1 root root 4096 Nov 15 10:30 ..
-rw-r--r--   1 root root   16 Nov 15 10:30 app.txt        ← 우리 파일
drwxr-xr-x   2 root root 4096 Nov 15 10:30 bin            ← 시스템 파일
drwxr-xr-x   2 root root 4096 Nov 15 10:30 boot           ← 시스템 파일
-rw-r--r--   1 root root   18 Nov 15 10:30 config.json    ← 우리 파일
drwxr-xr-x   5 root root  360 Nov 15 10:30 dev            ← 시스템 파일
drwxr-xr-x  30 root root 4096 Nov 15 10:30 etc            ← 시스템 파일
drwxr-xr-x   2 root root 4096 Nov 15 10:30 home           ← 시스템 파일
drwxr-xr-x   8 root root 4096 Nov 15 10:30 lib            ← 시스템 파일
drwxr-xr-x   2 root root 4096 Nov 15 10:30 media          ← 시스템 파일
drwxr-xr-x   2 root root 4096 Nov 15 10:30 mnt            ← 시스템 파일
drwxr-xr-x   2 root root 4096 Nov 15 10:30 opt            ← 시스템 파일
dr-xr-xr-x 114 root root    0 Nov 15 10:30 proc           ← 시스템 파일
drwx------   2 root root 4096 Nov 15 10:30 root           ← 시스템 파일
drwxr-xr-x   5 root root 4096 Nov 15 10:30 run            ← 시스템 파일
drwxr-xr-x   2 root root 4096 Nov 15 10:30 sbin           ← 시스템 파일
drwxr-xr-x   2 root root 4096 Nov 15 10:30 src            ← 우리 폴더
drwxr-xr-x   2 root root 4096 Nov 15 10:30 srv            ← 시스템 파일
dr-xr-xr-x  13 root root    0 Nov 15 10:30 sys            ← 시스템 파일
drwxrwxrwt   2 root root 4096 Nov 15 10:30 tmp            ← 시스템 파일
drwxr-xr-x  10 root root 4096 Nov 15 10:30 usr            ← 시스템 파일
drwxr-xr-x  11 root root 4096 Nov 15 10:30 var            ← 시스템 파일

문제점:
- 우리 파일들이 시스템 파일들과 뒤섞임
- 루트 디렉토리(/)가 지저분해짐
- 관리하기 어려운 구조
```

### 3. WORKDIR을 썼을 때

`WORKDIR`을 썼을 때 파일이 어떻게 구성되는지 확인해보죠.

**Dockerfile**

```docker
FROM ubuntu

WORKDIR /my-dir

COPY ./ ./

ENTRYPOINT ["/bin/bash", "-c", "sleep 500"]
```

```bash
$ docker build -t my-server .
$ docker run -d my-server
$ docker exec -it [Container ID] bash

$ ls
```

### **WORKDIR 사용했을 때 결과**

```bash
컨테이너 접속 시 위치:
root@def456abc123:/my-dir*# pwd*
/my-dir

현재 디렉토리 내용:
root@def456abc123:/my-dir*# ls -la*
total 16
drwxr-xr-x 3 root root 4096 Nov 15 10:35 .
drwxr-xr-x 1 root root 4096 Nov 15 10:35 ..
-rw-r--r-- 1 root root   16 Nov 15 10:35 app.txt
-rw-r--r-- 1 root root   18 Nov 15 10:35 config.json
drwxr-xr-x 2 root root 4096 Nov 15 10:35 src

루트 디렉토리 확인:
root@def456abc123:/my-dir*# cd /*
root@def456abc123:/*# ls*
bin  boot  dev  etc  home  lib  lib32  lib64  libx32  media  mnt  my-dir  opt  proc  root  run  sbin  srv  sys  tmp  usr  var

장점:
- 애플리케이션 파일들이 /my-dir에 깔끔하게 정리됨
- 시스템 파일들과 분리됨
- 관리하기 쉬운 구조
- 컨테이너 접속 시 바로 작업 디렉토리로 이동
```

### WORKDIR 고급 활용법

### **여러 번 사용하기**

```docker
FROM ubuntu

WORKDIR /app
RUN echo "Setting up app directory"

WORKDIR /app/config
COPY config.json .

WORKDIR /app/src
COPY src/ .

WORKDIR /app
*# 최종 작업 디렉토리는 /app*
```

### **상대 경로 사용**

```docker
FROM ubuntu

WORKDIR /usr
WORKDIR src     # /usr/src가 됨
WORKDIR app     # /usr/src/app이 됨

*# 현재 작업 디렉토리: /usr/src/app*
```

### **환경 변수와 함께 사용**

```docker
FROM ubuntu

ENV APP_HOME=/application
WORKDIR $APP_HOME

*# /application 디렉토리가 작업 디렉토리가 됨*
```

### 실제 프로젝트에서의 WORKDIR 사용

### **Node.js 프로젝트**

```docker
FROM node:18

WORKDIR /usr/src/app

COPY package*.json ./
RUN npm install

COPY . .

EXPOSE 3000
CMD ["npm", "start"]
```

### **Python 프로젝트**

```docker
FROM python:3.11

WORKDIR /app

COPY requirements.txt .
RUN pip install -r requirements.txt

COPY . .

CMD ["python", "app.py"]
```

### **Java Spring Boot 프로젝트**

```docker
FROM openjdk:17-jdk

WORKDIR /app

COPY build/libs/*.jar app.jar

ENTRYPOINT ["java", "-jar", "/app.jar"]
```

### WORKDIR 베스트 프랙티스

### **권장 디렉토리 경로**

```docker
일반적인 관례:
/app                 *# 가장 일반적*
/usr/src/app        *# Node.js 관례*
/opt/app            *# 선택적 소프트웨어용*
/home/user/app      *# 비루트 사용자용*

피해야 할 경로:
/                   *# 루트 디렉토리 (시스템 파일과 충돌)*
/bin, /usr/bin      *# 시스템 바이너리 디렉토리*
/etc                *# 시스템 설정 디렉토리*
```

### **보안 고려사항**

```docker
*# 비루트 사용자와 함께 사용*
FROM ubuntu

RUN groupadd -r appgroup && useradd -r -g appgroup appuser

WORKDIR /app
RUN chown appuser:appgroup /app

USER appuser

COPY --chown=appuser:appgroup . .
```

WORKDIR을 적절히 사용하면 컨테이너 내부를 체계적으로 관리할 수 있고, 시스템 파일들과 애플리케이션 파일들을 깔끔하게 분리할 수 있습니다.