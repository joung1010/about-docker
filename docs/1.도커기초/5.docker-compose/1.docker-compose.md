## Docker Compose를 사용하는 이유

### Docker Compose란?

여러 개의 Docker 컨테이너들을 하나의 서비스로 정의하고 구성해 하나의 묶음으로 관리할 수 있게 도와주는 툴입니다.

### Docker Compose를 사용하는 이유

### **1. 여러 개의 컨테이너를 관리하는 데 용이**

여러 개의 컨테이너로 이루어진 복잡한 애플리케이션을 한 번에 관리할 수 있게 해줍니다. 여러 컨테이너를 하나의 환경에서 실행하고 관리하는 데 도움이 됩니다.

```
실제 웹 애플리케이션 구성 예시:
┌─────────────────────────────────────────────────────┐
│                Multi-Container App                  │
├─────────────────────────────────────────────────────┤
│  Frontend (React)     │  Backend (Spring Boot)     │
│  Container: web       │  Container: api             │
│  Port: 3000          │  Port: 8080                 │
├─────────────────────────────────────────────────────┤
│  Database (MySQL)     │  Cache (Redis)              │
│  Container: db        │  Container: cache           │
│  Port: 3306          │  Port: 6379                 │
├─────────────────────────────────────────────────────┤
│  Monitoring (Nginx)   │  Volume Storage             │
│  Container: proxy     │  Persistent Data            │
│  Port: 80            │  /var/lib/mysql             │
└─────────────────────────────────────────────────────┘

Docker CLI로 관리 시:
$ docker run -d --name db mysql:8.0 ...
$ docker run -d --name cache redis:7 ...
$ docker run -d --name api springboot-app ...
$ docker run -d --name web react-app ...
$ docker run -d --name proxy nginx ...
*# 5개의 명령어, 복잡한 네트워크 설정 필요*

Docker Compose로 관리 시:
$ docker compose up -d
*# 한 번의 명령어로 모든 컨테이너 실행*
```

### **2. 복잡한 명령어로 실행시키던 걸 간소화 시킬 수 있음**

이전에 MySQL 이미지를 컨테이너로 실행시킬 때 아래와 같은 명령어를 실행시켰습니다.

```bash
$ docker run -e MYSQL_ROOT_PASSWORD=password123 -p 3306:3306 -v /Users/jaeseong/Documents/Develop/docker-mysql/mysql_data:/var/lib/mysql -d mysql
```

너무 복잡하지 않나요? Docker Compose를 사용하면 위와 같이 컨테이너를 실행시킬 때마다 복잡한 명령어를 입력하지 않아도 됩니다. 단순히 `docker compose up` 명령어만 실행시키면 됩니다.

### **3. 환경별 설정 관리**

```bash
개발, 스테이징, 프로덕션 환경별 관리:
docker-compose.yml          *# 기본 설정*
docker-compose.override.yml *# 개발 환경 (기본으로 적용)*
docker-compose.prod.yml     *# 프로덕션 환경*

$ docker compose up                           *# 개발 환경*
$ docker compose -f docker-compose.yml \
  -f docker-compose.prod.yml up              *# 프로덕션 환경*
```

## 기본 사용법 비교

### Docker CLI로 컨테이너를 실행시킬 때

```bash
$ docker run --name webserver -d -p 80:80 nginx
```

### Docker Compose로 컨테이너를 실행시킬 때

### **1. compose.yml 파일 작성하기**

**compose.yml**

```yaml
services:
  my-web-server:
    container_name: webserver
    image: nginx
    ports: 
      - "80:80"
```

**옵션 설명:**

- `services: my-web-server`: Docker Compose에서 하나의 컨테이너를 **서비스(service)**라고 부릅니다. 이 옵션은 **서비스에 이름**을 붙이는 기능입니다.
- `container_name: webserver`: 컨테이너를 띄울 때 붙이는 별칭입니다. CLI에서 `-name webserver` 역할과 동일합니다.
- `image: nginx`: 컨테이너를 실행시킬 때 어떤 이미지를 사용할지 정의하는 명령어입니다. `$ docker run [이미지명]`와 동일한 역할입니다.
- `ports`: 포트 매핑은 어떻게 할지를 설정하는 옵션입니다. CLI에서 `p 80:80` 역할과 동일합니다.

### **2. compose 파일 실행시키기**

```bash
$ docker compose up -d
```

### **3. compose 실행 현황 보기**

```bash
$ docker compose ps
$ docker ps
```

### **4. localhost:80 들어가보기**

### **5. compose로 실행된 컨테이너 삭제**

```bash
$ docker compose down
```

## 자주 사용하는 Docker Compose CLI 명령어

아래 명령어들은 `compose.yml`이 존재하는 디렉토리에서 실행시켜야 합니다.

### compose 파일 작성

**compose.yml**

```yaml
services:
  webserver:
    container_name: webserver
    image: nginx
    ports: 
      - "80:80"
```

### compose.yml에서 정의한 컨테이너 실행

```bash
$ docker compose up    *# 포그라운드에서 실행*
$ docker compose up -d *# 백그라운드에서 실행*
```

- `d`: 백그라운드에서 실행

### Docker Compose로 실행시킨 컨테이너 확인하기

```bash
*# compose.yml에 정의된 컨테이너 중 실행 중인 컨테이너만 보여줍니다.*
$ docker compose ps 

*# compose.yml에 정의된 모든 컨테이너를 보여줍니다.*
$ docker compose ps -a
```

### Docker Compose 로그 확인하기

```bash
*# compose.yml에 정의된 모든 컨테이너의 로그를 모아서 출력합니다.*
$ docker compose logs

*# 특정 서비스의 로그만 확인*
$ docker compose logs webserver

*# 실시간 로그 추적*
$ docker compose logs -f

*# 마지막 50줄만 확인*
$ docker compose logs --tail 50
```

### 컨테이너를 실행하기 전에 이미지 재빌드하기

```bash
$ docker compose up --build    *# 포그라운드에서 실행*
$ docker compose up --build -d *# 백그라운드에서 실행*
```

- `compose.yml`에서 정의한 이미지 파일에서 코드가 변경됐을 경우, 이미지를 다시 빌드해서 컨테이너를 실행시켜야 코드 변경된 부분이 적용됩니다. 그러므로 이럴 때에는 `-build` 옵션을 추가해서 사용해야 합니다.

**참고**: `docker compose up` vs `docker compose up --build`

- `docker compose up`: 이미지가 없을 때만 빌드해서 컨테이너를 실행시킵니다. 이미지가 이미 존재하는 경우 이미지를 빌드하지 않고 컨테이너를 실행시킵니다.
- `docker compose up --build`: 이미지가 있건 없건 무조건 빌드를 다시해서 컨테이너를 실행시킵니다.

### 이미지 다운받기/업데이트하기

bash

`$ docker compose pull`

- `compose.yml`에서 정의된 이미지를 다운받거나 업데이트합니다.
    - 로컬 환경에 이미지가 없다면 이미지를 다운받습니다.
    - 로컬 환경에 이미 이미지가 있는데, Docker Hub의 이미지와 다른 이미지일 경우 이미지를 업데이트합니다.

### Docker Compose에서 이용한 컨테이너 종료하기

bash

```bash
$ docker compose down

*# 볼륨까지 함께 삭제*
$ docker compose down -v

*# 이미지까지 함께 삭제*
$ docker compose down --rmi all
```

## 고급 활용 사례

### 1. 실제 웹 애플리케이션 구성

```yaml
*# docker-compose.yml*
version: '3.8'

services:
  *# 프론트엔드*
  frontend:
    build: ./frontend
    ports:
      - "3000:3000"
    depends_on:
      - backend
    environment:
      - REACT_APP_API_URL=http://localhost:8080

  *# 백엔드 API*
  backend:
    build: ./backend
    ports:
      - "8080:8080"
    depends_on:
      - database
      - redis
    environment:
      - DB_HOST=database
      - DB_USER=myuser
      - DB_PASSWORD=mypassword
      - REDIS_URL=redis://redis:6379

  *# 데이터베이스*
  database:
    image: mysql:8.0
    environment:
      - MYSQL_ROOT_PASSWORD=rootpassword
      - MYSQL_DATABASE=myapp
      - MYSQL_USER=myuser
      - MYSQL_PASSWORD=mypassword
    volumes:
      - mysql_data:/var/lib/mysql
    ports:
      - "3306:3306"

  *# 캐시*
  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"

  *# 리버스 프록시*
  nginx:
    image: nginx:alpine
    ports:
      - "80:80"
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf
    depends_on:
      - frontend
      - backend

volumes:
  mysql_data:
```

### 2. 개발 환경과 프로덕션 환경 분리

```yaml
*# docker-compose.override.yml (개발 환경)*
version: '3.8'

services:
  backend:
    volumes:
      - ./backend:/app
      - /app/node_modules
    environment:
      - NODE_ENV=development
      - DEBUG=true

  database:
    ports:
      - "3306:3306"  *# 개발시에만 외부 접근 허용*
```

```yaml
*# docker-compose.prod.yml (프로덕션 환경)*
version: '3.8'

services:
  backend:
    environment:
      - NODE_ENV=production
      - DEBUG=false

  database:
    *# 포트 노출하지 않음 (보안)# ports 설정 제거*
```

### 3. 네트워크 설정

```yaml
version: '3.8'

services:
  web:
    image: nginx
    networks:
      - frontend

  api:
    image: node:18
    networks:
      - frontend
      - backend

  db:
    image: postgres:15
    networks:
      - backend

networks:
  frontend:
    driver: bridge
  backend:
    driver: bridge
    internal: true  *# 외부 접근 차단*
```

## 변환 도구

지금까지의 예제를 보면 **Docker CLI**로 작성할 수 있는 명령어는 전부 **compose.yml** 파일로 옮길 수 있습니다. 반대로 **compose.yml**에 작성한 모든 값은 **Docker CLI**로 나타낼 수 있습니다. 이를 편하게 변환해주는 사이트가 존재합니다.

### Docker CLI → compose.yml로 변환

[Composerize](https://www.composerize.com/)

### compose.yml → Docker CLI로 변환

https://www.decomposerize.com/