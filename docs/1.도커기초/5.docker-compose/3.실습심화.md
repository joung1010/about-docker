## 1. Docker 기본 개념과 작동 원리

### Docker란 무엇인가?

Docker는 **컨테이너 기반의 오픈소스 가상화 플랫폼**입니다. 애플리케이션을 컨테이너라는 독립적인 실행 환경에 패키징하여 어느 환경에서든 동일하게 실행할 수 있게 해주는 기술입니다.

### 기존 가상화 기술과의 차이점

**기존 VM (Virtual Machine)**

- 하이퍼바이저 위에 게스트 OS 전체를 올리는 방식
- 높은 자원 소모 (각 VM마다 독립적인 OS 필요)
- 부팅 시간이 오래 걸림

**Docker 컨테이너**

- 호스트 OS의 커널을 공유하는 방식
- 낮은 자원 소모 (OS 레벨에서 프로세스 격리)
- 빠른 시작 시간 (초 단위)

### Docker 핵심 구성 요소

**1. 이미지 (Image)**

- 컨테이너 실행에 필요한 파일과 설정값들을 포함한 **읽기 전용 템플릿**
- 레이어 구조로 구성되어 효율적인 저장 가능
- Dockerfile을 통해 빌드됨

**2. 컨테이너 (Container)**

- 이미지를 실행한 **인스턴스**
- 독립적인 파일시스템, 네트워크, 프로세스 공간을 가짐
- 상태를 가질 수 있음 (실행 중, 정지됨, 삭제됨)

**3. Dockerfile**

- 이미지를 빌드하기 위한 **명령어들을 담은 텍스트 파일**
- 애플리케이션과 그 의존성을 정의

### Docker 네트워킹 원리

Docker는 여러 네트워크 드라이버를 제공합니다:

**1. Bridge 네트워크 (기본값)**

- 각 컨테이너는 독립적인 IP 주소를 할당받음
- 동일한 브리지 네트워크의 컨테이너들은 서로 통신 가능
- 호스트와는 포트 매핑을 통해 통신

**2. Host 네트워크**

- 컨테이너가 호스트의 네트워크를 직접 사용
- 네트워크 성능은 좋지만 격리성이 떨어짐

**3. None 네트워크**

- 네트워크가 완전히 비활성화된 상태

---

## 2. Docker Compose를 활용한 멀티 컨테이너 관리

### Docker Compose란?

Docker Compose는 **여러 개의 컨테이너로 구성된 애플리케이션을 정의하고 실행하는 도구**입니다. YAML 파일을 사용하여 애플리케이션의 서비스들을 구성하고, 단일 명령어로 모든 서비스를 생성하고 시작할 수 있습니다.

### 기본 멀티 서비스 구성

```yaml
*# compose.yml*
services:
  my-db:
    image: mysql:8.0  *# 버전 명시 권장*
    environment:
      MYSQL_ROOT_PASSWORD: pwd1234
      MYSQL_DATABASE: mydb
      MYSQL_CHARSET: utf8mb4
      MYSQL_COLLATION: utf8mb4_unicode_ci
    volumes:
      - mysql_data:/var/lib/mysql  *# Named volume 사용 권장*
      - ./init.sql:/docker-entrypoint-initdb.d/init.sql  *# 초기 스키마 설정*
    ports:
      - "3306:3306"
    restart: unless-stopped  *# 재시작 정책 추가*
    healthcheck:
      test: ["CMD", "mysqladmin", "ping", "-h", "localhost"]
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 30s

  my-cache-server:
    image: redis:7-alpine  *# Alpine 버전으로 경량화*
    ports:
      - "6379:6379"
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "redis-cli", "--raw", "incr", "ping"]
      interval: 10s
      timeout: 3s
      retries: 5
    command: redis-server --appendonly yes  *# 데이터 영속성 설정*
    volumes:
      - redis_data:/data

volumes:
  mysql_data:
    driver: local
  redis_data:
    driver: local
```

**주요 개선 사항:**

- **Named Volume 사용**: 호스트 경로 의존성 제거
- **버전 태그 명시**: 예측 가능한 배포
- **재시작 정책**: 장애 복구 자동화
- **헬스체크 최적화**: 더 안정적인 서비스 상태 확인

### Spring Boot 애플리케이션 통합

```yaml
*# compose.yml*
services:
  my-server:
    build: 
      context: .
      dockerfile: Dockerfile
      target: production  *# Multi-stage build 활용*
    ports:
      - "8080:8080"
    environment:
      - SPRING_PROFILES_ACTIVE=docker
      - SPRING_DATASOURCE_URL=jdbc:mysql://my-db:3306/mydb
      - SPRING_REDIS_HOST=my-cache-server
      - JAVA_OPTS=-Xmx512m -Xms256m  *# JVM 메모리 최적화*
    depends_on:
      my-db:
        condition: service_healthy
      my-cache-server:
        condition: service_healthy
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8080/actuator/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 60s
    networks:
      - app-network

  my-db:
    image: mysql:8.0
    environment:
      MYSQL_ROOT_PASSWORD: pwd1234
      MYSQL_DATABASE: mydb
      MYSQL_USER: app_user
      MYSQL_PASSWORD: app_pass
    volumes:
      - mysql_data:/var/lib/mysql
      - ./docker/mysql/conf.d:/etc/mysql/conf.d  *# MySQL 설정 커스터마이징*
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "mysqladmin", "ping", "-h", "localhost", "-u", "root", "-p$$MYSQL_ROOT_PASSWORD"]
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 30s
    networks:
      - app-network

  my-cache-server:
    image: redis:7-alpine
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 3s
      retries: 5
    volumes:
      - redis_data:/data
    networks:
      - app-network

networks:
  app-network:
    driver: bridge
    ipam:
      config:
        - subnet: 172.20.0.0/16

volumes:
  mysql_data:
  redis_data:
```

### 컨테이너 간 네트워킹 심화 이해

**네트워크 격리 원리**

각 컨테이너는 **네트워크 네임스페이스**라는 독립적인 네트워크 환경을 가집니다:

1. **독립적인 IP 주소**: 각 컨테이너는 Docker가 관리하는 가상 네트워크에서 고유한 IP를 할당받습니다
2. **포트 공간 격리**: 같은 포트 번호를 여러 컨테이너가 사용할 수 있습니다
3. **DNS 해석**: Docker Compose는 서비스 이름을 IP 주소로 자동 변환하는 내장 DNS를 제공합니다

**서비스 간 통신 메커니즘**

```
Spring Boot Container (my-server)
├── Network Namespace: 172.20.0.2
├── Hostname: my-server
└── Resolves: my-db → 172.20.0.3

MySQL Container (my-db)
├── Network Namespace: 172.20.0.3
├── Hostname: my-db
└── Listens on: 0.0.0.0:3306

Redis Container (my-cache-server)
├── Network Namespace: 172.20.0.4
├── Hostname: my-cache-server
└── Listens on: 0.0.0.0:6379
```

**Spring Boot 설정 최적화**

```yaml
*# application-docker.yml*
spring:
  datasource:
    url: jdbc:mysql://my-db:3306/mydb?useSSL=false&allowPublicKeyRetrieval=true&serverTimezone=Asia/Seoul
    username: app_user
    password: app_pass
    hikari:
      maximum-pool-size: 10
      minimum-idle: 5
      connection-timeout: 30000
      idle-timeout: 600000
      max-lifetime: 1800000
  
  data:
    redis:
      host: my-cache-server
      port: 6379
      timeout: 2000ms
      lettuce:
        pool:
          max-active: 8
          max-idle: 8
          min-idle: 0

  jpa:
    database-platform: org.hibernate.dialect.MySQL8Dialect
    hibernate:
      ddl-auto: validate
    show-sql: false
    properties:
      hibernate:
        format_sql: true
        jdbc:
          batch_size: 20
        order_inserts: true
        order_updates: true

management:
  endpoints:
    web:
      exposure:
        include: health,info,metrics
  endpoint:
    health:
      show-details: always
```

---

## 3. 심화 과정: 프로덕션 환경 고려사항

### Multi-stage Dockerfile 최적화

```docker
*# Multi-stage build for Spring Boot*
FROM eclipse-temurin:17-jdk-alpine AS builder
WORKDIR /app
COPY gradlew .
COPY gradle gradle
COPY build.gradle settings.gradle ./
COPY src src
RUN ./gradlew clean build -x test

FROM eclipse-temurin:17-jre-alpine AS production
RUN addgroup -g 1001 -S appgroup && \
    adduser -u 1001 -S appuser -G appgroup
WORKDIR /app
COPY --from=builder /app/build/libs/*.jar app.jar
RUN chown appuser:appgroup app.jar
USER appuser
EXPOSE 8080
HEALTHCHECK --interval=30s --timeout=3s --start-period=60s --retries=3 \
  CMD wget --no-verbose --tries=1 --spider http://localhost:8080/actuator/health || exit 1
ENTRYPOINT ["java", "-jar", "/app/app.jar"]
```

### 보안 강화 설정

```yaml
*# compose.prod.yml*
services:
  my-server:
    build:
      target: production
    environment:
      - SPRING_PROFILES_ACTIVE=prod,docker
    secrets:
      - db_password
      - redis_password
    deploy:
      resources:
        limits:
          cpus: '1.0'
          memory: 1G
        reservations:
          cpus: '0.5'
          memory: 512M

  my-db:
    environment:
      MYSQL_ROOT_PASSWORD_FILE: /run/secrets/db_root_password
      MYSQL_PASSWORD_FILE: /run/secrets/db_password
    secrets:
      - db_root_password
      - db_password
    security_opt:
      - no-new-privileges:true
    read_only: true
    tmpfs:
      - /tmp
      - /var/run/mysqld

secrets:
  db_root_password:
    file: ./secrets/db_root_password.txt
  db_password:
    file: ./secrets/db_password.txt
  redis_password:
    file: ./secrets/redis_password.txt
```

### 모니터링 및 로깅

```yaml
*# compose.monitoring.yml*
services:
  prometheus:
    image: prom/prometheus:latest
    volumes:
      - ./monitoring/prometheus.yml:/etc/prometheus/prometheus.yml
      - prometheus_data:/prometheus
    ports:
      - "9090:9090"
    networks:
      - monitoring

  grafana:
    image: grafana/grafana:latest
    environment:
      - GF_SECURITY_ADMIN_PASSWORD=admin
    volumes:
      - grafana_data:/var/lib/grafana
      - ./monitoring/grafana/dashboards:/var/lib/grafana/dashboards
    ports:
      - "3000:3000"
    networks:
      - monitoring
      - app-network

  loki:
    image: grafana/loki:latest
    volumes:
      - ./monitoring/loki-config.yml:/etc/loki/local-config.yaml
      - loki_data:/loki
    networks:
      - monitoring

volumes:
  prometheus_data:
  grafana_data:
  loki_data:

networks:
  monitoring:
    driver: bridge
```

### 개발/운영 환경 분리

```bash
*# 개발 환경*
docker compose -f compose.yml -f compose.dev.yml up -d

*# 스테이징 환경*  
docker compose -f compose.yml -f compose.staging.yml up -d

*# 프로덕션 환경*
docker compose -f compose.yml -f compose.prod.yml up -d
```

### 실행 명령어 가이드

```bash
*# 1. 프로젝트 빌드 및 이미지 생성*
./gradlew clean build
docker compose build

*# 2. 서비스 실행 (백그라운드)*
docker compose up -d

*# 3. 특정 서비스만 재시작*
docker compose restart my-server

*# 4. 로그 확인*
docker compose logs -f my-server

*# 5. 서비스 스케일링*
docker compose up -d --scale my-server=3

*# 6. 헬스체크 상태 확인*
docker compose ps

*# 7. 전체 환경 정리*
docker compose down -v --remove-orphans

*# 8. 이미지까지 함께 정리*
docker compose down -v --rmi all
```

---

## 4. 트러블슈팅 가이드

### 자주 발생하는 문제들

**1. 컨테이너 간 통신 실패**

- 원인: 잘못된 서비스 네임 사용, 네트워크 설정 오류
- 해결: `docker network ls`, `docker network inspect` 명령어로 네트워크 상태 확인

**2. 볼륨 마운트 권한 문제**

- 원인: 호스트와 컨테이너 간 UID/GID 불일치
- 해결: Dockerfile에서 적절한 사용자 설정, chown 명령어 활용

**3. 메모리 부족**

- 원인: JVM 힙 메모리 설정 과다, 컨테이너 메모리 제한 미설정
- 해결: `deploy.resources.limits` 설정, JVM 옵션 튜닝